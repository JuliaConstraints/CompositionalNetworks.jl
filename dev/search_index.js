var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CompositionalNetworks","category":"page"},{"location":"#Compositional-Networks","page":"Home","title":"Compositional Networks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CompositionalNetworks]","category":"page"},{"location":"#CompositionalNetworks._abs_diff_val_param-Union{Tuple{T}, Tuple{T,T}} where T<:Number","page":"Home","title":"CompositionalNetworks._abs_diff_val_param","text":"_abs_diff_val_param(x::T, param::T)\n\nReturn the absolute difference between x and param.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._abs_diff_val_vars-Union{Tuple{V}, Tuple{T}, Tuple{T,V}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._abs_diff_val_vars","text":"_abs_diff_val_vars(x::T, vars::V)\n\nReturn the absolute difference between x and the number of variables.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._contiguous_vals_minus-Union{Tuple{V}, Tuple{T}, Tuple{Int64,V}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._contiguous_vals_minus","text":"_contiguous_vals_minus(i::Int, x::V)\n_contiguous_vals_minus_rev(i::Int, x::V)\n\nReturn the difference x[i] - x[i + 1] (resp. x[i + 1] - x[i]) if positive, 0.0 otherwise. Extended method to vector with sig (x::V) are generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._count_bounding_param-Union{Tuple{V}, Tuple{T}, Tuple{Int64,V,T}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._count_bounding_param","text":"_count_bounding_param(i::Int, x::V, param::T)\n\nCount the number of elements bounded (not strictly) by x[i] and x[i] + param. An extended method to vector with sig (x::V, param::T) is generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._count_eq-Union{Tuple{V}, Tuple{T}, Tuple{Int64,V}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._count_eq","text":"_count_eq(i::Int, x::V)\n_count_eq_right(i::Int, x::V)\n_count_eq_left(i::Int, x::V)\n\nCount the number of elements equal to x[i] (optionally to the right/left of x[i]). Extended method to vector x::V are generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._count_eq_param-Union{Tuple{V}, Tuple{T}, Tuple{Int64,V,T}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._count_eq_param","text":"_count_eq_param(i::Int, x::V, param::T)\n_count_l_param(i::Int, x::V, param::T)\n_count_g_param(i::Int, x::V, param::T)\n\nCount the number of elements equal to (resp. lesser/greater than) x[i] + param. Extended method to vector with sig (x::V, param::T) are generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._count_greater-Union{Tuple{V}, Tuple{T}, Tuple{Int64,V}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._count_greater","text":"_count_greater(i::Int, x::V)\n_count_lesser(i::Int, x::V)\n_count_g_left(i::Int, x::V)\n_count_l_left(i::Int, x::V)\n_count_g_right(i::Int, x::V)\n_count_l_right(i::Int, x::V)\n\nCount the number of elements greater/lesser than x[i] (optionally to the left/right of x[i]). Extended method to vector with sig (x::V) are generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._count_positive-Union{Tuple{V}, Tuple{T}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._count_positive","text":"_count_positive(x::V)\n\nCount the number of strictly positive elements of x.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._euclidian_param-Union{Tuple{T2}, Tuple{T}, Tuple{T,T,T2}} where T2<:Number where T<:Number","page":"Home","title":"CompositionalNetworks._euclidian_param","text":"_euclidian_param(x::T, param::T, dom_size::T2)\n_euclidian(x::T, dom_size::T2)\n\nCompute an euclidian norm , possibly weigthed by param, on a scalar.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._identity-Union{Tuple{V}, Tuple{T}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._identity","text":"_identity(x::V) where {T <: Number,V <: AbstractVector{T}}\n_identity(x::T) where T <: Number = identity(x)\n\nIdentity function. Already defined in Julia as identity, specialized for vectors and scalars.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._map_tr-Tuple{Any,Any}","page":"Home","title":"CompositionalNetworks._map_tr","text":"_map_tr(f, x)\n_map_tr(f, x, param)\n\nReturn an anonymous function that applies f to all elements of x, with an optional parameter param.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._sum-Union{Tuple{V}, Tuple{T}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._sum","text":"_sum(x::V)\n\nAggregate through + a vector into a single scalar.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._sum-Union{Tuple{W}, Tuple{V}, Tuple{T}} where W<:AbstractArray{V,1} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._sum","text":"_sum(x::W) where {T <: Number, V <: AbstractVector{T}, W <: AbstractVector{V}}\n_prod(x::W) where {T <: Number, V <: AbstractVector{T}, W <: AbstractVector{V}}\n\nReduce k = length(x) vectors through sum/product to a single vector.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._val_minus_param-Union{Tuple{T}, Tuple{T,T}} where T<:Number","page":"Home","title":"CompositionalNetworks._val_minus_param","text":"_val_minus_param(x::T, param::T)\n_param_minus_val(x::T, param::T)\n\nReturn the difference x - param (resp. param - x) if positive, 0.0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._val_minus_param-Union{Tuple{V}, Tuple{T}, Tuple{Int64,V,T}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._val_minus_param","text":"_val_minus_param(i::Int, x::V, param::T)\n_param_minus_val(i::Int, x::V, param::T)\n\nReturn the difference x[i] - param (resp. param - x[i]) if positive, 0.0 otherwise.  Extended method to vector with sig (x::V, param::T) are generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._val_minus_vars-Union{Tuple{V}, Tuple{T}, Tuple{T,V}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._val_minus_vars","text":"_val_minus_vars(x::T, vars::V)\n_vars_minus_val(x::T, vars::V)\n\nReturn the difference x - length(vars) (resp. length(vars) - x) if positive, 0.0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.lazy-Tuple{Vararg{Function,N} where N}","page":"Home","title":"CompositionalNetworks.lazy","text":"lazy(funcs::Function...)\nlazy_param(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. For lazy (resp. lazy_param) a function f should have the following signature: f(i::Int, x::V) (resp. f(i::Int, x::V, param::T)).\n\n\n\n\n\n","category":"method"}]
}
