var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CompositionalNetworks","category":"page"},{"location":"#Compositional-Networks","page":"Home","title":"Compositional Networks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CompositionalNetworks]","category":"page"},{"location":"#CompositionalNetworks.ICN","page":"Home","title":"CompositionalNetworks.ICN","text":"ICN(; nvars, dom_size, param, transformation, arithmetic, aggregation, comparison)\n\nConstruct an Interpretable Compositional Network, with the following arguments:\n\nnvars: number of variable in the constraint\ndom_size: maximum domain size of any variable in the constraint\nparam: optional parameter (default to nothing)\ntransformation: a transformation layer (optional)\narithmetic: a arithmetic layer (optional)\naggregation: a aggregation layer (optional)\ncomparison: a comparison layer (optional)\n\n\n\n\n\n","category":"type"},{"location":"#CompositionalNetworks._ag_count_positive-Tuple{Any}","page":"Home","title":"CompositionalNetworks._ag_count_positive","text":"_ag_count_positive(x)\n\nCount the number of strictly positive elements of x.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._ag_sum-Tuple{Any}","page":"Home","title":"CompositionalNetworks._ag_sum","text":"_ag_sum(x)\n\nAggregate through + a vector into a single scalar.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._ar_sum-Tuple{Any}","page":"Home","title":"CompositionalNetworks._ar_sum","text":"_ar_sum(x)\n_ar_prod(x)\n\nReduce k = length(x) vectors through sum/product to a single vector.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._as_bitvector","page":"Home","title":"CompositionalNetworks._as_bitvector","text":"_as_bitvector(n::Int, max_n::Int = n)\n\nConvert an Int to a BitVector of minimal size (relatively to max_n).\n\n\n\n\n\n","category":"function"},{"location":"#CompositionalNetworks._as_int-Tuple{AbstractArray{T,1} where T}","page":"Home","title":"CompositionalNetworks._as_int","text":"_as_int(v::AbstractVector)\n\nConvert a BitVector into an Int.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._co_abs_diff_val_param-Tuple{Any}","page":"Home","title":"CompositionalNetworks._co_abs_diff_val_param","text":"_co_abs_diff_val_param(x, param)\n\nReturn the absolute difference between x and param.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._co_abs_diff_val_vars-Tuple{Any}","page":"Home","title":"CompositionalNetworks._co_abs_diff_val_vars","text":"_co_abs_diff_val_vars(x, nvars)\n\nReturn the absolute difference between x and the number of variables nvars.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._co_euclidian_param-Tuple{Any}","page":"Home","title":"CompositionalNetworks._co_euclidian_param","text":"_co_euclidian_param(x, param, ds)\n_co_euclidian(x, ds)\n\nCompute an euclidian norm with domain size ds, possibly weigthed by param, on a scalar.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._co_identity-Tuple{Any}","page":"Home","title":"CompositionalNetworks._co_identity","text":"_co_identity(x::Number)\n\nIdentity function. Already defined in Julia as identity, specialized for scalars in the comparison layer.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._co_val_minus_param-Tuple{Any}","page":"Home","title":"CompositionalNetworks._co_val_minus_param","text":"_co_val_minus_param(x, param)\n_co_param_minus_val(x, param)\n\nReturn the difference x - param (resp. param - x) if positive, 0.0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._co_val_minus_vars-Tuple{Any}","page":"Home","title":"CompositionalNetworks._co_val_minus_vars","text":"_co_val_minus_vars(x, nvars)\n_co_vars_minus_val(x, nvars)\n\nReturn the difference x - nvars (resp. nvars - x) if positive, 0.0 otherwise, where nvars denotes the numbers of variables.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._compose-Tuple{ICN}","page":"Home","title":"CompositionalNetworks._compose","text":"_compose(icn)\n\nInternal function called by compose and show_composition.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._exclu-Tuple{Any}","page":"Home","title":"CompositionalNetworks._exclu","text":"_exclu(layer)\n\nReturn true if the layer has mutually exclusive operations.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._functions-Tuple{Any}","page":"Home","title":"CompositionalNetworks._functions","text":"_functions(layer)\n\nAccess the operations of a layer. The container is ordered.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._generate_inclusive_operations-Tuple{Any,Any}","page":"Home","title":"CompositionalNetworks._generate_inclusive_operations","text":"_generate_inclusive_operations(predicate, bits)\n_generate_exclusive_operation(max_op_number)\n\nGenerates the operations (weigths) of a layer with inclusive/exclusive operations.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._generate_population-Tuple{Any,Any}","page":"Home","title":"CompositionalNetworks._generate_population","text":"_generate_population(icn, pop_size\n\nGenerate a p√¥pulation of weigths (individuals) for the genetic algorithm weigthing icn.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._generate_weights-Tuple{Any}","page":"Home","title":"CompositionalNetworks._generate_weights","text":"_generate_weights(layers)\n_generate_weights(icn)\n\nGenerate the weigths of a collection of layers or of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._is_viable-Tuple{CompositionalNetworks.Layer,Any}","page":"Home","title":"CompositionalNetworks._is_viable","text":"_is_viable(layer, w)\n_is_viable(icn)\n_is_viable(icn, w)\n\nAssert if a pair of layer/icn and weigths compose a viable pattern. If no weigths are given with an icn, it will check the current internal value.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._layers-Tuple{Any}","page":"Home","title":"CompositionalNetworks._layers","text":"_layers(icn)\n\nReturn the ordered layers of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._loss-NTuple{7,Any}","page":"Home","title":"CompositionalNetworks._loss","text":"_loss(X, X_sols, icn, weigths, metric)\n\nCompute the loss of icn.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._map_tr-Tuple{Any,Any,Any}","page":"Home","title":"CompositionalNetworks._map_tr","text":"_map_tr(f, x, param)\n\nReturn an anonymous function that applies f to all elements of x, with a parameter param (which is set to nothing for function with no parameter).\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._nbits-Tuple{Any}","page":"Home","title":"CompositionalNetworks._nbits","text":"_nbits(icn)\n\nReturn the expected number of bits of a viable weigth of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._nbits_exclu-Tuple{Any}","page":"Home","title":"CompositionalNetworks._nbits_exclu","text":"_nbits_exclu(layer)\n\nConvert the length of an exclusive layer into a number of bits.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._optimize!","page":"Home","title":"CompositionalNetworks._optimize!","text":"_optimize!(icn, X, X_sols; metric = hamming, pop_size = 200)\n\nOptimize and set the weigths of an ICN with a given set of configuration X and solutions X_sols.\n\n\n\n\n\n","category":"function"},{"location":"#CompositionalNetworks._reduce_symbols","page":"Home","title":"CompositionalNetworks._reduce_symbols","text":"_reduce_symbols(symbols, sep)\n\nProduce a formatted string that separates the symbols by sep. Used internally for show_composition.\n\n\n\n\n\n","category":"function"},{"location":"#CompositionalNetworks._selected_size-Tuple{Any,Any}","page":"Home","title":"CompositionalNetworks._selected_size","text":"_selected_size(layer, layer_weights)\n\nReturn the number of operations selected by layer_weights in layer.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._show_layer-Tuple{Any}","page":"Home","title":"CompositionalNetworks._show_layer","text":"_show_layer(layer)\n\nReturn a string that contains the elements in a layer.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._symbol-Tuple{Any,Any}","page":"Home","title":"CompositionalNetworks._symbol","text":"_symbol(layer, i)\n\nReturn the i-th symbols of the operations in a given layer. \n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._tr_contiguous_vals_minus-Tuple{Any,Any}","page":"Home","title":"CompositionalNetworks._tr_contiguous_vals_minus","text":"_tr_contiguous_vals_minus(i, x)\n_tr_contiguous_vals_minus_rev(i, x)\n\nReturn the difference x[i] - x[i + 1] (resp. x[i + 1] - x[i]) if positive, 0.0 otherwise. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._tr_count_bounding_param-Tuple{Any,Any}","page":"Home","title":"CompositionalNetworks._tr_count_bounding_param","text":"_tr_count_bounding_param(i, x, param)\n\nCount the number of elements bounded (not strictly) by x[i] and x[i] + param. An extended method to vector with sig (x, param) is generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._tr_count_eq-Tuple{Any,Any}","page":"Home","title":"CompositionalNetworks._tr_count_eq","text":"_tr_count_eq(i, x)\n_tr_count_eq_right(i, x)\n_tr_count_eq_left(i, x)\n\nCount the number of elements equal to x[i] (optionally to the right/left of x[i]). Extended method to vector x are generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._tr_count_eq_param-Tuple{Any,Any}","page":"Home","title":"CompositionalNetworks._tr_count_eq_param","text":"_tr_count_eq_param(i, x, param)\n_tr_count_l_param(i, x, param)\n_tr_count_g_param(i, x, param)\n\nCount the number of elements equal to (resp. lesser/greater than) x[i] + param. Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._tr_count_greater-Tuple{Any,Any}","page":"Home","title":"CompositionalNetworks._tr_count_greater","text":"_tr_count_greater(i, x)\n_tr_count_lesser(i, x)\n_tr_count_g_left(i, x)\n_tr_count_l_left(i, x)\n_tr_count_g_right(i, x)\n_tr_count_l_right(i, x)\n\nCount the number of elements greater/lesser than x[i] (optionally to the left/right of x[i]). Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._tr_identity-Tuple{Any}","page":"Home","title":"CompositionalNetworks._tr_identity","text":"_tr_identity(x)\n_tr_identity(x)\n\nIdentity function. Already defined in Julia as identity, specialized for vectors and scalars.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._tr_val_minus_param-Tuple{Any,Any}","page":"Home","title":"CompositionalNetworks._tr_val_minus_param","text":"_tr_val_minus_param(i, x, param)\n_tr_param_minus_val(i, x, param)\n\nReturn the difference x[i] - param (resp. param - x[i]) if positive, 0.0 otherwise.  Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._weigths!-Tuple{Any,Any}","page":"Home","title":"CompositionalNetworks._weigths!","text":"_weights!(icn, weights)\n\nSet the weights of an ICN with a BitVector.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._weigths-Tuple{Any}","page":"Home","title":"CompositionalNetworks._weigths","text":"_weigths(icn)\n\nAccess the current set of weigths of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.aggregation_layer-Tuple{}","page":"Home","title":"CompositionalNetworks.aggregation_layer","text":"aggregation_layer()\n\nGenerate the layer of aggregation functions of the ICN.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.arithmetic_layer-Tuple{}","page":"Home","title":"CompositionalNetworks.arithmetic_layer","text":"arithmetic_layer()\n\nGenerate the layer of arithmetic functions of the ICN.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.comparison_layer","page":"Home","title":"CompositionalNetworks.comparison_layer","text":"comparison_layer(nvars, dom_size, param = nothing)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is set, also includes all the parametric transformation with that value.\n\n\n\n\n\n","category":"function"},{"location":"#CompositionalNetworks.compose-Tuple{ICN}","page":"Home","title":"CompositionalNetworks.compose","text":"compose(icn)\ncompose(icn, weights)\n\nReturn a function composed by some of the operations of a given ICN. Can be applied to any vector of variables. If weights are given, will assign to icn.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.csv2space-Tuple{Any}","page":"Home","title":"CompositionalNetworks.csv2space","text":"csv2space(file; filter=:none)\n\nConvert a csv file into a collection of configurations. If the filter is set to :concept, only solutions will be extracted.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.hamming-Tuple{Any,Any}","page":"Home","title":"CompositionalNetworks.hamming","text":"hamming(x, X)\n\nCompute the hamming distance of x over a collection of solutions X, i.e. the minimal number of variables to switch in xto reach a solution.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.lazy-Tuple{Vararg{Function,N} where N}","page":"Home","title":"CompositionalNetworks.lazy","text":"lazy(funcs::Function...)\nlazy_param(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. For lazy (resp. lazy_param) a function f should have the following signature: f(i::Int, x::V) (resp. f(i::Int, x::V, param::T)).\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.learn_compose","page":"Home","title":"CompositionalNetworks.learn_compose","text":"learn_compose(;\n    nvars, dom_size, param=nothing, icn=ICN(nvars, dom_size, param),\n    X, X_sols, global_iter=100, local_iter=100, metric=hamming, popSize=200\n)\n\nCreate an ICN, optimize it, and return its composition.\n\n\n\n\n\n","category":"function"},{"location":"#CompositionalNetworks.regularization-Tuple{Any}","page":"Home","title":"CompositionalNetworks.regularization","text":"regularization(icn)\n\nReturn the regularization value of an ICN weights, which is proportional to the normalized number of operations selected in the icn layers.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.show_composition-Tuple{Any}","page":"Home","title":"CompositionalNetworks.show_composition","text":"show_composition(icn)\n\nReturn the composition (weights) of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.show_layers-Tuple{Any}","page":"Home","title":"CompositionalNetworks.show_layers","text":"show_layers(icn)\n\nReturn a formated string with each layers in the icn.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.transformation_layer","page":"Home","title":"CompositionalNetworks.transformation_layer","text":"transformation_layer(param = nothing)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is set, also includes all the parametric transformation with that value.\n\n\n\n\n\n","category":"function"},{"location":"#ConstraintDomains._length-Tuple{CompositionalNetworks.Layer}","page":"Home","title":"ConstraintDomains._length","text":"_length(layer)\n\nReturn the number of operations in a layer.\n\n\n\n\n\n","category":"method"},{"location":"#ConstraintDomains._length-Tuple{ICN}","page":"Home","title":"ConstraintDomains._length","text":"_length(icn)\n\nReturn the total number of operations of an ICN.\n\n\n\n\n\n","category":"method"}]
}
