var documenterSearchIndex = {"docs":
[{"location":"comparison/#Comparison-Layer","page":"Comparison","title":"Comparison Layer","text":"","category":"section"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"The comparison layer of our basic ICN can be constructed using comparison_layer(param=false). All operations are mutually exclusive.","category":"page"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"CompositionalNetworks.comparison_layer","category":"page"},{"location":"comparison/#CompositionalNetworks.comparison_layer","page":"Comparison","title":"CompositionalNetworks.comparison_layer","text":"comparison_layer(param = false)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is set, also includes all the parametric comparison with that value. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#Non-parametric-comparisons","page":"Comparison","title":"Non-parametric comparisons","text":"","category":"section"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"Follows a list of the current non-parametric operations available in any comparison layer.","category":"page"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"CompositionalNetworks._co_identity\nCompositionalNetworks._co_euclidian\nCompositionalNetworks._co_abs_diff_val_vars\nCompositionalNetworks._co_val_minus_vars\nCompositionalNetworks._co_vars_minus_val","category":"page"},{"location":"comparison/#CompositionalNetworks._co_identity","page":"Comparison","title":"CompositionalNetworks._co_identity","text":"_co_identity(x)\n\nIdentity function. Already defined in Julia as identity, specialized for scalars in the comparison layer.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#CompositionalNetworks._co_euclidian","page":"Comparison","title":"CompositionalNetworks._co_euclidian","text":"_co_euclidian(x; dom_size)\n\nCompute an euclidian norm with domain size dom_size of a scalar.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#CompositionalNetworks._co_abs_diff_val_vars","page":"Comparison","title":"CompositionalNetworks._co_abs_diff_val_vars","text":"_co_abs_diff_val_vars(x; nvars)\n\nReturn the absolute difference between x and the number of variables nvars.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#CompositionalNetworks._co_val_minus_vars","page":"Comparison","title":"CompositionalNetworks._co_val_minus_vars","text":"_co_val_minus_vars(x; nvars)\n\nReturn the difference x - nvars if positive, 0.0 otherwise, where nvars denotes the numbers of variables.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#CompositionalNetworks._co_vars_minus_val","page":"Comparison","title":"CompositionalNetworks._co_vars_minus_val","text":"_co_vars_minus_val(x; nvars)\n\nReturn the difference nvars - x if positive, 0.0 otherwise, where nvars denotes the numbers of variables.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#Parametric-comparisons","page":"Comparison","title":"Parametric comparisons","text":"","category":"section"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"And finally a list of the parametric ones.","category":"page"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"CompositionalNetworks._co_abs_diff_val_param\nCompositionalNetworks._co_val_minus_param\nCompositionalNetworks._co_param_minus_val\nCompositionalNetworks._co_euclidian_param","category":"page"},{"location":"comparison/#CompositionalNetworks._co_abs_diff_val_param","page":"Comparison","title":"CompositionalNetworks._co_abs_diff_val_param","text":"_co_abs_diff_val_param(x; param)\n\nReturn the absolute difference between x and param.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#CompositionalNetworks._co_val_minus_param","page":"Comparison","title":"CompositionalNetworks._co_val_minus_param","text":"_co_val_minus_param(x; param)\n\nReturn the difference x - param if positive, 0.0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#CompositionalNetworks._co_param_minus_val","page":"Comparison","title":"CompositionalNetworks._co_param_minus_val","text":"_co_param_minus_val(x; param)\n\nReturn the difference param - x if positive, 0.0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#CompositionalNetworks._co_euclidian_param","page":"Comparison","title":"CompositionalNetworks._co_euclidian_param","text":"_co_euclidian_param(x; param, dom_size)\n\nCompute an euclidian norm with domain size dom_size, weigthed by param, of a scalar.\n\n\n\n\n\n","category":"function"},{"location":"aggregation/#Aggregation-Layer","page":"Aggregation","title":"Aggregation Layer","text":"","category":"section"},{"location":"aggregation/","page":"Aggregation","title":"Aggregation","text":"The aggregation layer of our basic ICN can be constructed using aggregation_layer().","category":"page"},{"location":"aggregation/","page":"Aggregation","title":"Aggregation","text":"CompositionalNetworks.aggregation_layer","category":"page"},{"location":"aggregation/#CompositionalNetworks.aggregation_layer","page":"Aggregation","title":"CompositionalNetworks.aggregation_layer","text":"aggregation_layer()\n\nGenerate the layer of aggregations of the ICN. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"function"},{"location":"aggregation/#List-of-Aggregations","page":"Aggregation","title":"List of Aggregations","text":"","category":"section"},{"location":"aggregation/","page":"Aggregation","title":"Aggregation","text":"Follows a list of the current operations available in any aggregation layer. Those operations are mutually exclusive.","category":"page"},{"location":"aggregation/","page":"Aggregation","title":"Aggregation","text":"CompositionalNetworks._ag_sum\nCompositionalNetworks._ag_count_positive","category":"page"},{"location":"aggregation/#CompositionalNetworks._ag_sum","page":"Aggregation","title":"CompositionalNetworks._ag_sum","text":"_ag_sum(x)\n\nAggregate through + a vector into a single scalar.\n\n\n\n\n\n","category":"function"},{"location":"aggregation/#CompositionalNetworks._ag_count_positive","page":"Aggregation","title":"CompositionalNetworks._ag_count_positive","text":"_ag_count_positive(x)\n\nCount the number of strictly positive elements of x.\n\n\n\n\n\n","category":"function"},{"location":"arithmetic/#Arithmetic-Layer","page":"Arithmetic","title":"Arithmetic Layer","text":"","category":"section"},{"location":"arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"The arithmetic layer of our basic ICN can be constructed using arithmetic_layer().","category":"page"},{"location":"arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"CompositionalNetworks.arithmetic_layer","category":"page"},{"location":"arithmetic/#CompositionalNetworks.arithmetic_layer","page":"Arithmetic","title":"CompositionalNetworks.arithmetic_layer","text":"arithmetic_layer()\n\nGenerate the layer of arithmetic operations of the ICN. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"function"},{"location":"arithmetic/#List-of-Arithmetic-operations","page":"Arithmetic","title":"List of Arithmetic operations","text":"","category":"section"},{"location":"arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"Follows a list of the current operations available in any arithmetic layer. Those operations are mutually exclusive.","category":"page"},{"location":"arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"CompositionalNetworks._ar_sum\nCompositionalNetworks._ar_prod","category":"page"},{"location":"arithmetic/#CompositionalNetworks._ar_sum","page":"Arithmetic","title":"CompositionalNetworks._ar_sum","text":"_ar_sum(x)\n\nReduce k = length(x) vectors through sum to a single vector.\n\n\n\n\n\n","category":"function"},{"location":"arithmetic/#CompositionalNetworks._ar_prod","page":"Arithmetic","title":"CompositionalNetworks._ar_prod","text":"_ar_prod(x)\n\nReduce k = length(x) vectors through product to a single vector.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CompositionalNetworks","category":"page"},{"location":"#CompositionalNetworks.jl","page":"Home","title":"CompositionalNetworks.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CompositionalNetworks.jl, a Julia package for Interpretable Compositional Networks (ICN), a variant of neural networks, allowing the user to get interpretable results, unlike regular artificial neural networks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The current state of our ICN focuses on the composition of error functions for LocalSearchSolvers.jl, but produces results independently of it and export it to either/both Julia functions or/and human readable output.","category":"page"},{"location":"#How-does-it-work?","page":"Home","title":"How does it work?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package comes with a basic ICN for learning global constraints. The ICN is composed of 4 layers: transformation, arithmetic, aggregation, and comparison. Each contains several operations that can be composed in various ways. Given a concept (a predicate over the variables' domains), a metric (hamming by default), and the variables' domains, we learn the binary weights of the ICN. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"] add CompositionalNetworks","category":"page"},{"location":"","page":"Home","title":"Home","text":"As the package is in a beta version, some changes in the syntax and features are likely to occur. However, those changes should be minimal between minor versions. Please update with caution.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# 4 variables in 1:4\ndoms = [domain([1,2,3,4]) for i in 1:4]\n\n# allunique concept (that is used to define the :all_different constraint)\nerr = explore_learn_compose(allunique, domains=doms)\n# > interpretation: identity ∘ count_positive ∘ sum ∘ count_eq_left\n\n# test our new error function\n@assert err([1,2,3,3], dom_size = 4) > 0.0\n\n# export an all_different function to file \"current/path/test_dummy.jl\" \ncompose_to_file!(icn, \"all_different\", \"test_dummy.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output file should produces a function that can be used as follows (assuming the maximum domain size is 7)","category":"page"},{"location":"","page":"Home","title":"Home","text":"import CompositionalNetworks\n\nall_different([1,2,3,4,5,6,7]; dom_size = 7)\n# > 0.0 (which means true, no errors)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please see JuliaConstraints/Constraints.jl/learn.jl for an extensive example of ICN learning and compositions.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions to this package are more than welcome and can be arbitrarily, and not exhaustively, split as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Adding (useful) operations in one of the 4 existing layers\nCreating other ICNs from scratch or with only some of the original operations\nCreating an ICN with a layer structure\nCreating other compositional networks which target other problems\nJust making stuff better, faster, user-friendlier, etc.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Do not hesitate to contact me (@azzaare) or other members of JuliaConstraints on GitHub (file an issue), the julialang discourse forum, the julialang slack channel, the julialang zulip server, or the Human of Julia (HoJ) discord server.","category":"page"},{"location":"transformation/#Transformation-Layer","page":"Transformation","title":"Transformation Layer","text":"","category":"section"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"The transformation layer of our basic ICN can be constructed using transformation_layer(param=false).","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"CompositionalNetworks.transformation_layer","category":"page"},{"location":"transformation/#CompositionalNetworks.transformation_layer","page":"Transformation","title":"CompositionalNetworks.transformation_layer","text":"transformation_layer(param = false)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is true, also includes all the parametric transformations.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#Non-parametric-transformations","page":"Transformation","title":"Non-parametric transformations","text":"","category":"section"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"Follows a list of the current non-parametric operations available in any transformation layer.","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"CompositionalNetworks._tr_identity\nCompositionalNetworks._tr_count_eq\nCompositionalNetworks._tr_count_eq_left\nCompositionalNetworks._tr_count_eq_right\nCompositionalNetworks._tr_count_greater\nCompositionalNetworks._tr_count_lesser\nCompositionalNetworks._tr_count_g_left\nCompositionalNetworks._tr_count_l_left\nCompositionalNetworks._tr_count_g_right\nCompositionalNetworks._tr_count_l_right\nCompositionalNetworks._tr_contiguous_vals_minus\nCompositionalNetworks._tr_contiguous_vals_minus_rev","category":"page"},{"location":"transformation/#CompositionalNetworks._tr_identity","page":"Transformation","title":"CompositionalNetworks._tr_identity","text":"_tr_identity(x)\n_tr_identity(i, x)\n\nIdentity function. Already defined in Julia as identity, specialized for vectors.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_eq","page":"Transformation","title":"CompositionalNetworks._tr_count_eq","text":"_tr_count_eq(i, x)\n_tr_count_eq(x)\n\nCount the number of elements equal to x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_eq_left","page":"Transformation","title":"CompositionalNetworks._tr_count_eq_left","text":"_tr_count_eq_left(i, x)\n_tr_count_eq_left(x)\n\nCount the number of elements to the left of and equal to x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_eq_right","page":"Transformation","title":"CompositionalNetworks._tr_count_eq_right","text":"_tr_count_eq_right(i, x)\n_tr_count_eq_right(x)\n\nCount the number of elements to the right of and equal to x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_greater","page":"Transformation","title":"CompositionalNetworks._tr_count_greater","text":"_tr_count_greater(i, x)\n_tr_count_greater(x)\n\nCount the number of elements greater than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_lesser","page":"Transformation","title":"CompositionalNetworks._tr_count_lesser","text":"_tr_count_lesser(i, x)\n_tr_count_lesser(x)\n\nCount the number of elements lesser than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_g_left","page":"Transformation","title":"CompositionalNetworks._tr_count_g_left","text":"_tr_count_g_left(i, x)\n_tr_count_g_left(x)\n\nCount the number of elements to the left of and greater than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_l_left","page":"Transformation","title":"CompositionalNetworks._tr_count_l_left","text":"_tr_count_l_left(i, x)\n_tr_count_l_left(x)\n\nCount the number of elements to the left of and lesser than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_g_right","page":"Transformation","title":"CompositionalNetworks._tr_count_g_right","text":"_tr_count_g_right(i, x)\n_tr_count_g_right(x)\n\nCount the number of elements to the right of and greater than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_l_right","page":"Transformation","title":"CompositionalNetworks._tr_count_l_right","text":"_tr_count_l_right(i, x)\n_tr_count_l_right(x)\n\nCount the number of elements to the right of and lesser than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_contiguous_vals_minus","page":"Transformation","title":"CompositionalNetworks._tr_contiguous_vals_minus","text":"_tr_contiguous_vals_minus(i, x)\n_tr_contiguous_vals_minus(x)\n\nReturn the difference x[i] - x[i + 1] if positive, 0.0 otherwise. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_contiguous_vals_minus_rev","page":"Transformation","title":"CompositionalNetworks._tr_contiguous_vals_minus_rev","text":"_tr_contiguous_vals_minus_rev(i, x)\n_tr_contiguous_vals_minus_rev(x)\n\nReturn the difference x[i + 1] - x[i] if positive, 0.0 otherwise. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"Note that all functions are extended to a vectorized version with the lazy function.","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"CompositionalNetworks.lazy","category":"page"},{"location":"transformation/#CompositionalNetworks.lazy","page":"Transformation","title":"CompositionalNetworks.lazy","text":"lazy(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. A function f should have the following signature: f(i::Int, x::V; param = nothing).\n\n\n\n\n\n","category":"function"},{"location":"transformation/#Parametric-transformations","page":"Transformation","title":"Parametric transformations","text":"","category":"section"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"And finally a list of the parametric ones.","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"CompositionalNetworks._tr_count_eq_param\nCompositionalNetworks._tr_count_l_param\nCompositionalNetworks._tr_count_g_param\nCompositionalNetworks._tr_count_bounding_param\nCompositionalNetworks._tr_val_minus_param\nCompositionalNetworks._tr_param_minus_val","category":"page"},{"location":"transformation/#CompositionalNetworks._tr_count_eq_param","page":"Transformation","title":"CompositionalNetworks._tr_count_eq_param","text":"_tr_count_eq_param(i, x; param)\n_tr_count_eq_param(x; param)\n\nCount the number of elements equal to x[i] + param. Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_l_param","page":"Transformation","title":"CompositionalNetworks._tr_count_l_param","text":"_tr_count_l_param(i, x; param)\n_tr_count_l_param(x; param)\n\nCount the number of elements lesser than x[i] + param. Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_g_param","page":"Transformation","title":"CompositionalNetworks._tr_count_g_param","text":"_tr_count_g_param(i, x; param)\n_tr_count_g_param(x; param)\n\nCount the number of elements greater than x[i] + param. Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_bounding_param","page":"Transformation","title":"CompositionalNetworks._tr_count_bounding_param","text":"_tr_count_bounding_param(i, x; param)\n_tr_count_bounding_param(x; param)\n\nCount the number of elements bounded (not strictly) by x[i] and x[i] + param. An extended method to vector with sig (x, param) is generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_val_minus_param","page":"Transformation","title":"CompositionalNetworks._tr_val_minus_param","text":"_tr_val_minus_param(i, x; param)\n_tr_val_minus_param(x; param)\n\nReturn the difference x[i] - param if positive, 0.0 otherwise.  Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_param_minus_val","page":"Transformation","title":"CompositionalNetworks._tr_param_minus_val","text":"_tr_param_minus_val(i, x; param)\n_tr_param_minus_val(x; param)\n\nReturn the difference param - x[i] if positive, 0.0 otherwise.  Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"Note that all functions are extended to a vectorized version with the lazy_param function.","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"CompositionalNetworks.lazy_param","category":"page"},{"location":"transformation/#CompositionalNetworks.lazy_param","page":"Transformation","title":"CompositionalNetworks.lazy_param","text":"lazy_param(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. A function f should have the following signature: f(i::Int, x::V; param).\n\n\n\n\n\n","category":"function"}]
}
