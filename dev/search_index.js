var documenterSearchIndex = {"docs":
[{"location":"domain/#ConstraintDomains.jl-(dependency)","page":"ConstraintDomains.jl (dependency)","title":"ConstraintDomains.jl (dependency)","text":"","category":"section"},{"location":"domain/","page":"ConstraintDomains.jl (dependency)","title":"ConstraintDomains.jl (dependency)","text":"Currently only discrete domains are supported using the following function. ","category":"page"},{"location":"domain/","page":"ConstraintDomains.jl (dependency)","title":"ConstraintDomains.jl (dependency)","text":"ConstraintDomains.domain","category":"page"},{"location":"domain/#ConstraintDomains.domain","page":"ConstraintDomains.jl (dependency)","title":"ConstraintDomains.domain","text":"domain(values::AbstractVector; type = :set)\n\nDiscrete domain constructor. The type keyword can be set to :set (default) or :indices.\n\nd1 = domain([1,2,3,4], type = :indices)\nd2 = domain([53.69, 89.2, 0.12])\nd3 = domain([2//3, 89//123])\n\n\n\n\n\n","category":"function"},{"location":"comparison/#Comparison-Layer","page":"Comparison","title":"Comparison Layer","text":"","category":"section"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"The comparison layer of our basic ICN can be constructed using comparison_layer(param=false). All operations are mutually exclusive.","category":"page"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"CompositionalNetworks.comparison_layer","category":"page"},{"location":"comparison/#CompositionalNetworks.comparison_layer","page":"Comparison","title":"CompositionalNetworks.comparison_layer","text":"comparison_layer(param = false)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is set, also includes all the parametric comparison with that value. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#Non-parametric-comparisons","page":"Comparison","title":"Non-parametric comparisons","text":"","category":"section"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"Follows a list of the current non-parametric operations available in any comparison layer.","category":"page"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"CompositionalNetworks._co_identity\nCompositionalNetworks._co_euclidian\nCompositionalNetworks._co_abs_diff_val_vars\nCompositionalNetworks._co_val_minus_vars\nCompositionalNetworks._co_vars_minus_val","category":"page"},{"location":"comparison/#CompositionalNetworks._co_identity","page":"Comparison","title":"CompositionalNetworks._co_identity","text":"_co_identity(x)\n\nIdentity function. Already defined in Julia as identity, specialized for scalars in the comparison layer.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#CompositionalNetworks._co_euclidian","page":"Comparison","title":"CompositionalNetworks._co_euclidian","text":"_co_euclidian(x; dom_size)\n\nCompute an euclidian norm with domain size dom_size of a scalar.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#CompositionalNetworks._co_abs_diff_val_vars","page":"Comparison","title":"CompositionalNetworks._co_abs_diff_val_vars","text":"_co_abs_diff_val_vars(x; nvars)\n\nReturn the absolute difference between x and the number of variables nvars.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#CompositionalNetworks._co_val_minus_vars","page":"Comparison","title":"CompositionalNetworks._co_val_minus_vars","text":"_co_val_minus_vars(x; nvars)\n\nReturn the difference x - nvars if positive, 0.0 otherwise, where nvars denotes the numbers of variables.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#CompositionalNetworks._co_vars_minus_val","page":"Comparison","title":"CompositionalNetworks._co_vars_minus_val","text":"_co_vars_minus_val(x; nvars)\n\nReturn the difference nvars - x if positive, 0.0 otherwise, where nvars denotes the numbers of variables.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#Parametric-comparisons","page":"Comparison","title":"Parametric comparisons","text":"","category":"section"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"And finally a list of the parametric ones.","category":"page"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"CompositionalNetworks._co_abs_diff_val_param\nCompositionalNetworks._co_val_minus_param\nCompositionalNetworks._co_param_minus_val\nCompositionalNetworks._co_euclidian_param","category":"page"},{"location":"comparison/#CompositionalNetworks._co_abs_diff_val_param","page":"Comparison","title":"CompositionalNetworks._co_abs_diff_val_param","text":"_co_abs_diff_val_param(x; param)\n\nReturn the absolute difference between x and param.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#CompositionalNetworks._co_val_minus_param","page":"Comparison","title":"CompositionalNetworks._co_val_minus_param","text":"_co_val_minus_param(x; param)\n\nReturn the difference x - param if positive, 0.0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#CompositionalNetworks._co_param_minus_val","page":"Comparison","title":"CompositionalNetworks._co_param_minus_val","text":"_co_param_minus_val(x; param)\n\nReturn the difference param - x if positive, 0.0 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#CompositionalNetworks._co_euclidian_param","page":"Comparison","title":"CompositionalNetworks._co_euclidian_param","text":"_co_euclidian_param(x; param, dom_size)\n\nCompute an euclidian norm with domain size dom_size, weigthed by param, of a scalar.\n\n\n\n\n\n","category":"function"},{"location":"icn/#ICNs","page":"ICNs","title":"ICNs","text":"","category":"section"},{"location":"icn/","page":"ICNs","title":"ICNs","text":"Currently only construct a generic ICN with all available operations.","category":"page"},{"location":"icn/","page":"ICNs","title":"ICNs","text":"CompositionalNetworks.ICN","category":"page"},{"location":"icn/#CompositionalNetworks.ICN","page":"ICNs","title":"CompositionalNetworks.ICN","text":"ICN(; nvars, dom_size, param, transformation, arithmetic, aggregation, comparison)\n\nConstruct an Interpretable Compositional Network, with the following arguments:\n\nnvars: number of variable in the constraint\ndom_size: maximum domain size of any variable in the constraint\nparam: optional parameter (default to nothing)\ntransformation: a transformation layer (optional)\narithmetic: a arithmetic layer (optional)\naggregation: a aggregation layer (optional)\ncomparison: a comparison layer (optional)\n\n\n\n\n\n","category":"type"},{"location":"public/#Public","page":"Public","title":"Public","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]\nDepth = 5","category":"page"},{"location":"public/","page":"Public","title":"Public","text":"Modules = [CompositionalNetworks]\nPrivate = false","category":"page"},{"location":"public/#CompositionalNetworks.aggregation_layer-Tuple{}","page":"Public","title":"CompositionalNetworks.aggregation_layer","text":"aggregation_layer()\n\nGenerate the layer of aggregations of the ICN. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.arithmetic_layer-Tuple{}","page":"Public","title":"CompositionalNetworks.arithmetic_layer","text":"arithmetic_layer()\n\nGenerate the layer of arithmetic operations of the ICN. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.comparison_layer","page":"Public","title":"CompositionalNetworks.comparison_layer","text":"comparison_layer(param = false)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is set, also includes all the parametric comparison with that value. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"function"},{"location":"public/#CompositionalNetworks.compose-Tuple{ICN}","page":"Public","title":"CompositionalNetworks.compose","text":"compose(icn)\ncompose(icn, weights)\n\nReturn a function composed by some of the operations of a given ICN. Can be applied to any vector of variables. If weights are given, will assign to icn.\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.csv2space-Tuple{Any}","page":"Public","title":"CompositionalNetworks.csv2space","text":"csv2space(file; filter=:none)\n\nConvert a csv file into a collection of configurations. If the filter is set to :concept, only solutions will be extracted.\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.hamming-Tuple{Any,Any}","page":"Public","title":"CompositionalNetworks.hamming","text":"hamming(x, X)\n\nCompute the hamming distance of x over a collection of solutions X, i.e. the minimal number of variables to switch in xto reach a solution.\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.lazy-Tuple{Vararg{Function,N} where N}","page":"Public","title":"CompositionalNetworks.lazy","text":"lazy(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. A function f should have the following signature: f(i::Int, x::V; param = nothing).\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.lazy_param-Tuple{Vararg{Function,N} where N}","page":"Public","title":"CompositionalNetworks.lazy_param","text":"lazy_param(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. A function f should have the following signature: f(i::Int, x::V; param).\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.learn_compose","page":"Public","title":"CompositionalNetworks.learn_compose","text":"learn_compose(;\n    nvars, dom_size, param=nothing, icn=ICN(nvars, dom_size, param),\n    X, X_sols, global_iter=100, local_iter=100, metric=hamming, popSize=200\n)\n\nCreate an ICN, optimize it, and return its composition.\n\n\n\n\n\n","category":"function"},{"location":"public/#CompositionalNetworks.regularization-Tuple{Any}","page":"Public","title":"CompositionalNetworks.regularization","text":"regularization(icn)\n\nReturn the regularization value of an ICN weights, which is proportional to the normalized number of operations selected in the icn layers.\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.show_composition-Tuple{Any}","page":"Public","title":"CompositionalNetworks.show_composition","text":"show_composition(icn)\n\nReturn the composition (weights) of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.show_layers-Tuple{Any}","page":"Public","title":"CompositionalNetworks.show_layers","text":"show_layers(icn)\n\nReturn a formated string with each layers in the icn.\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.transformation_layer","page":"Public","title":"CompositionalNetworks.transformation_layer","text":"transformation_layer(param = false)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is true, also includes all the parametric transformations.\n\n\n\n\n\n","category":"function"},{"location":"internal/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internal/","page":"Internals","title":"Internals","text":"Pages = [\"internal.md\"]\nDepth = 5","category":"page"},{"location":"internal/","page":"Internals","title":"Internals","text":"Modules = [CompositionalNetworks]\nPublic = false","category":"page"},{"location":"internal/#CompositionalNetworks._ag_count_positive-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._ag_count_positive","text":"_ag_count_positive(x)\n\nCount the number of strictly positive elements of x.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._ag_sum-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._ag_sum","text":"_ag_sum(x)\n\nAggregate through + a vector into a single scalar.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._ar_prod-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._ar_prod","text":"_ar_prod(x)\n\nReduce k = length(x) vectors through product to a single vector.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._ar_sum-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._ar_sum","text":"_ar_sum(x)\n\nReduce k = length(x) vectors through sum to a single vector.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._as_bitvector","page":"Internals","title":"CompositionalNetworks._as_bitvector","text":"_as_bitvector(n::Int, max_n::Int = n)\n\nConvert an Int to a BitVector of minimal size (relatively to max_n).\n\n\n\n\n\n","category":"function"},{"location":"internal/#CompositionalNetworks._as_int-Tuple{AbstractArray{T,1} where T}","page":"Internals","title":"CompositionalNetworks._as_int","text":"_as_int(v::AbstractVector)\n\nConvert a BitVector into an Int.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._co_abs_diff_val_param-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._co_abs_diff_val_param","text":"_co_abs_diff_val_param(x; param)\n\nReturn the absolute difference between x and param.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._co_abs_diff_val_vars-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._co_abs_diff_val_vars","text":"_co_abs_diff_val_vars(x; nvars)\n\nReturn the absolute difference between x and the number of variables nvars.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._co_euclidian-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._co_euclidian","text":"_co_euclidian(x; dom_size)\n\nCompute an euclidian norm with domain size dom_size of a scalar.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._co_euclidian_param-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._co_euclidian_param","text":"_co_euclidian_param(x; param, dom_size)\n\nCompute an euclidian norm with domain size dom_size, weigthed by param, of a scalar.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._co_identity-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._co_identity","text":"_co_identity(x)\n\nIdentity function. Already defined in Julia as identity, specialized for scalars in the comparison layer.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._co_param_minus_val-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._co_param_minus_val","text":"_co_param_minus_val(x; param)\n\nReturn the difference param - x if positive, 0.0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._co_val_minus_param-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._co_val_minus_param","text":"_co_val_minus_param(x; param)\n\nReturn the difference x - param if positive, 0.0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._co_val_minus_vars-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._co_val_minus_vars","text":"_co_val_minus_vars(x; nvars)\n\nReturn the difference x - nvars if positive, 0.0 otherwise, where nvars denotes the numbers of variables.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._co_vars_minus_val-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._co_vars_minus_val","text":"_co_vars_minus_val(x; nvars)\n\nReturn the difference nvars - x if positive, 0.0 otherwise, where nvars denotes the numbers of variables.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._compose-Tuple{ICN}","page":"Internals","title":"CompositionalNetworks._compose","text":"_compose(icn)\n\nInternal function called by compose and show_composition.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._exclu-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._exclu","text":"_exclu(layer)\n\nReturn true if the layer has mutually exclusive operations.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._functions-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._functions","text":"_functions(layer)\n\nAccess the operations of a layer. The container is ordered.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._generate_inclusive_operations-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._generate_inclusive_operations","text":"_generate_inclusive_operations(predicate, bits)\n_generate_exclusive_operation(max_op_number)\n\nGenerates the operations (weigths) of a layer with inclusive/exclusive operations.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._generate_population-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._generate_population","text":"_generate_population(icn, pop_size\n\nGenerate a pôpulation of weigths (individuals) for the genetic algorithm weigthing icn.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._generate_weights-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._generate_weights","text":"_generate_weights(layers)\n_generate_weights(icn)\n\nGenerate the weigths of a collection of layers or of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._is_viable-Tuple{CompositionalNetworks.Layer,Any}","page":"Internals","title":"CompositionalNetworks._is_viable","text":"_is_viable(layer, w)\n_is_viable(icn)\n_is_viable(icn, w)\n\nAssert if a pair of layer/icn and weigths compose a viable pattern. If no weigths are given with an icn, it will check the current internal value.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._layers-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._layers","text":"_layers(icn)\n\nReturn the ordered layers of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._loss-NTuple{7,Any}","page":"Internals","title":"CompositionalNetworks._loss","text":"_loss(X, X_sols, icn, weigths, metric)\n\nCompute the loss of icn.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._map_tr-Tuple{Any,Any,Any}","page":"Internals","title":"CompositionalNetworks._map_tr","text":"_map_tr(f, x, param)\n\nReturn an anonymous function that applies f to all elements of x, with a parameter param (which is set to nothing for function with no parameter).\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._nbits-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._nbits","text":"_nbits(icn)\n\nReturn the expected number of bits of a viable weigth of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._nbits_exclu-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._nbits_exclu","text":"_nbits_exclu(layer)\n\nConvert the length of an exclusive layer into a number of bits.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._optimize!","page":"Internals","title":"CompositionalNetworks._optimize!","text":"_optimize!(icn, X, X_sols; metric = hamming, pop_size = 200)\n\nOptimize and set the weigths of an ICN with a given set of configuration X and solutions X_sols.\n\n\n\n\n\n","category":"function"},{"location":"internal/#CompositionalNetworks._reduce_symbols","page":"Internals","title":"CompositionalNetworks._reduce_symbols","text":"_reduce_symbols(symbols, sep)\n\nProduce a formatted string that separates the symbols by sep. Used internally for show_composition.\n\n\n\n\n\n","category":"function"},{"location":"internal/#CompositionalNetworks._selected_size-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._selected_size","text":"_selected_size(layer, layer_weights)\n\nReturn the number of operations selected by layer_weights in layer.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._show_layer-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._show_layer","text":"_show_layer(layer)\n\nReturn a string that contains the elements in a layer.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._symbol-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._symbol","text":"_symbol(layer, i)\n\nReturn the i-th symbols of the operations in a given layer. \n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_contiguous_vals_minus-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_contiguous_vals_minus","text":"_tr_contiguous_vals_minus(i, x)\n_tr_contiguous_vals_minus(x)\n\nReturn the difference x[i] - x[i + 1] if positive, 0.0 otherwise. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_contiguous_vals_minus_rev-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_contiguous_vals_minus_rev","text":"_tr_contiguous_vals_minus_rev(i, x)\n_tr_contiguous_vals_minus_rev(x)\n\nReturn the difference x[i + 1] - x[i] if positive, 0.0 otherwise. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_count_bounding_param-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_count_bounding_param","text":"_tr_count_bounding_param(i, x; param)\n_tr_count_bounding_param(x; param)\n\nCount the number of elements bounded (not strictly) by x[i] and x[i] + param. An extended method to vector with sig (x, param) is generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_count_eq-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_count_eq","text":"_tr_count_eq(i, x)\n_tr_count_eq(x)\n\nCount the number of elements equal to x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_count_eq_left-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_count_eq_left","text":"_tr_count_eq_left(i, x)\n_tr_count_eq_left(x)\n\nCount the number of elements to the left of and equal to x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_count_eq_param-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_count_eq_param","text":"_tr_count_eq_param(i, x; param)\n_tr_count_eq_param(x; param)\n\nCount the number of elements equal to x[i] + param. Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_count_eq_right-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_count_eq_right","text":"_tr_count_eq_right(i, x)\n_tr_count_eq_right(x)\n\nCount the number of elements to the right of and equal to x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_count_g_left-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_count_g_left","text":"_tr_count_g_left(i, x)\n_tr_count_g_left(x)\n\nCount the number of elements to the left of and greater than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_count_g_param-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_count_g_param","text":"_tr_count_g_param(i, x; param)\n_tr_count_g_param(x; param)\n\nCount the number of elements greater than x[i] + param. Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_count_g_right-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_count_g_right","text":"_tr_count_g_right(i, x)\n_tr_count_g_right(x)\n\nCount the number of elements to the right of and greater than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_count_greater-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_count_greater","text":"_tr_count_greater(i, x)\n_tr_count_greater(x)\n\nCount the number of elements greater than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_count_l_left-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_count_l_left","text":"_tr_count_l_left(i, x)\n_tr_count_l_left(x)\n\nCount the number of elements to the left of and lesser than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_count_l_param-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_count_l_param","text":"_tr_count_l_param(i, x; param)\n_tr_count_l_param(x; param)\n\nCount the number of elements lesser than x[i] + param. Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_count_l_right-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_count_l_right","text":"_tr_count_l_right(i, x)\n_tr_count_l_right(x)\n\nCount the number of elements to the right of and lesser than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_count_lesser-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_count_lesser","text":"_tr_count_lesser(i, x)\n_tr_count_lesser(x)\n\nCount the number of elements lesser than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_identity-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._tr_identity","text":"_tr_identity(x)\n_tr_identity(i, x)\n\nIdentity function. Already defined in Julia as identity, specialized for vectors.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_param_minus_val-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_param_minus_val","text":"_tr_param_minus_val(i, x; param)\n_tr_param_minus_val(x; param)\n\nReturn the difference param - x[i] if positive, 0.0 otherwise.  Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._tr_val_minus_param-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._tr_val_minus_param","text":"_tr_val_minus_param(i, x; param)\n_tr_val_minus_param(x; param)\n\nReturn the difference x[i] - param if positive, 0.0 otherwise.  Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._weigths!-Tuple{Any,Any}","page":"Internals","title":"CompositionalNetworks._weigths!","text":"_weights!(icn, weights)\n\nSet the weights of an ICN with a BitVector.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._weigths-Tuple{Any}","page":"Internals","title":"CompositionalNetworks._weigths","text":"_weigths(icn)\n\nAccess the current set of weigths of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ConstraintDomains._length-Tuple{CompositionalNetworks.Layer}","page":"Internals","title":"ConstraintDomains._length","text":"_length(layer)\n\nReturn the number of operations in a layer.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ConstraintDomains._length-Tuple{ICN}","page":"Internals","title":"ConstraintDomains._length","text":"_length(icn)\n\nReturn the total number of operations of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"aggregation/#Aggregation-Layer","page":"Aggregation","title":"Aggregation Layer","text":"","category":"section"},{"location":"aggregation/","page":"Aggregation","title":"Aggregation","text":"The aggregation layer of our basic ICN can be constructed using aggregation_layer().","category":"page"},{"location":"aggregation/","page":"Aggregation","title":"Aggregation","text":"CompositionalNetworks.aggregation_layer","category":"page"},{"location":"aggregation/#CompositionalNetworks.aggregation_layer","page":"Aggregation","title":"CompositionalNetworks.aggregation_layer","text":"aggregation_layer()\n\nGenerate the layer of aggregations of the ICN. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"function"},{"location":"aggregation/#List-of-Aggregations","page":"Aggregation","title":"List of Aggregations","text":"","category":"section"},{"location":"aggregation/","page":"Aggregation","title":"Aggregation","text":"Follows a list of the current operations available in any aggregation layer. Those operations are mutually exclusive.","category":"page"},{"location":"aggregation/","page":"Aggregation","title":"Aggregation","text":"CompositionalNetworks._ag_sum\nCompositionalNetworks._ag_count_positive","category":"page"},{"location":"aggregation/#CompositionalNetworks._ag_sum","page":"Aggregation","title":"CompositionalNetworks._ag_sum","text":"_ag_sum(x)\n\nAggregate through + a vector into a single scalar.\n\n\n\n\n\n","category":"function"},{"location":"aggregation/#CompositionalNetworks._ag_count_positive","page":"Aggregation","title":"CompositionalNetworks._ag_count_positive","text":"_ag_count_positive(x)\n\nCount the number of strictly positive elements of x.\n\n\n\n\n\n","category":"function"},{"location":"arithmetic/#Arithmetic-Layer","page":"Arithmetic","title":"Arithmetic Layer","text":"","category":"section"},{"location":"arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"The arithmetic layer of our basic ICN can be constructed using arithmetic_layer().","category":"page"},{"location":"arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"CompositionalNetworks.arithmetic_layer","category":"page"},{"location":"arithmetic/#CompositionalNetworks.arithmetic_layer","page":"Arithmetic","title":"CompositionalNetworks.arithmetic_layer","text":"arithmetic_layer()\n\nGenerate the layer of arithmetic operations of the ICN. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"function"},{"location":"arithmetic/#List-of-Arithmetic-operations","page":"Arithmetic","title":"List of Arithmetic operations","text":"","category":"section"},{"location":"arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"Follows a list of the current operations available in any arithmetic layer. Those operations are mutually exclusive.","category":"page"},{"location":"arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"CompositionalNetworks._ar_sum\nCompositionalNetworks._ar_prod","category":"page"},{"location":"arithmetic/#CompositionalNetworks._ar_sum","page":"Arithmetic","title":"CompositionalNetworks._ar_sum","text":"_ar_sum(x)\n\nReduce k = length(x) vectors through sum to a single vector.\n\n\n\n\n\n","category":"function"},{"location":"arithmetic/#CompositionalNetworks._ar_prod","page":"Arithmetic","title":"CompositionalNetworks._ar_prod","text":"_ar_prod(x)\n\nReduce k = length(x) vectors through product to a single vector.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CompositionalNetworks","category":"page"},{"location":"#CompositionalNetworks.jl","page":"Home","title":"CompositionalNetworks.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CompositionalNetworks.jl, a Julia package for Interpretable Compositional Networks (ICN), a variant of neural networks, allowing the user to get interpretable results, unlike regular artificial neural networks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The current state of our ICN focuses on the composition of error functions for LocalSearchSolvers.jl, but produces results independently of it and export it to either/both Julia functions or/and human readable output.","category":"page"},{"location":"#How-does-it-work?","page":"Home","title":"How does it work?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package comes with a basic ICN for learning global constraints. The ICN is composed of 4 layers: transformation, arithmetic, aggregation, and comparison. Each contains several operations that can be composed in various ways. Given a concept (a predicate over the variables' domains), a metric (hamming by default), and the variables' domains, we learn the binary weights of the ICN. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"] add CompositionalNetworks","category":"page"},{"location":"","page":"Home","title":"Home","text":"As the package is in a beta version, some changes in the syntax and features are likely to occur. However, those changes should be minimal between minor versions. Please update with caution.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# 4 variables in 1:4\ndoms = [domain([1,2,3,4]) for i in 1:4]\n\n# allunique concept (that is used to define the :all_different constraint)\nerr = explore_learn_compose(allunique, domains=doms)\n# > interpretation: identity ∘ count_positive ∘ sum ∘ count_eq_left\n\n# test our new error function\n@assert err([1,2,3,3], dom_size = 4) > 0.0\n\n# export an all_different function to file \"current/path/test_dummy.jl\" \ncompose_to_file!(icn, \"all_different\", \"test_dummy.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output file should produces a function that can be used as follows (assuming the maximum domain size is 7)","category":"page"},{"location":"","page":"Home","title":"Home","text":"import CompositionalNetworks\n\nall_different([1,2,3,4,5,6,7]; dom_size = 7)\n# > 0.0 (which means true, no errors)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please see JuliaConstraints/Constraints.jl/learn.jl for an extensive example of ICN learning and compositions.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions to this package are more than welcome and can be arbitrarily, and not exhaustively, split as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Adding (useful) operations in one of the 4 existing layers\nCreating other ICNs from scratch or with only some of the original operations\nCreating an ICN with a layer structure\nCreating other compositional networks which target other problems\nJust making stuff better, faster, user-friendlier, etc.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Do not hesitate to contact me (@azzaare) or other members of JuliaConstraints on GitHub (file an issue), the julialang discourse forum, the julialang slack channel, the julialang zulip server, or the Human of Julia (HoJ) discord server.","category":"page"},{"location":"transformation/#Transformation-Layer","page":"Transformation","title":"Transformation Layer","text":"","category":"section"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"The transformation layer of our basic ICN can be constructed using transformation_layer(param=false).","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"CompositionalNetworks.transformation_layer","category":"page"},{"location":"transformation/#CompositionalNetworks.transformation_layer","page":"Transformation","title":"CompositionalNetworks.transformation_layer","text":"transformation_layer(param = false)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is true, also includes all the parametric transformations.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#Non-parametric-transformations","page":"Transformation","title":"Non-parametric transformations","text":"","category":"section"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"Follows a list of the current non-parametric operations available in any transformation layer.","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"CompositionalNetworks._tr_identity\nCompositionalNetworks._tr_count_eq\nCompositionalNetworks._tr_count_eq_left\nCompositionalNetworks._tr_count_eq_right\nCompositionalNetworks._tr_count_greater\nCompositionalNetworks._tr_count_lesser\nCompositionalNetworks._tr_count_g_left\nCompositionalNetworks._tr_count_l_left\nCompositionalNetworks._tr_count_g_right\nCompositionalNetworks._tr_count_l_right\nCompositionalNetworks._tr_contiguous_vals_minus\nCompositionalNetworks._tr_contiguous_vals_minus_rev","category":"page"},{"location":"transformation/#CompositionalNetworks._tr_identity","page":"Transformation","title":"CompositionalNetworks._tr_identity","text":"_tr_identity(x)\n_tr_identity(i, x)\n\nIdentity function. Already defined in Julia as identity, specialized for vectors.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_eq","page":"Transformation","title":"CompositionalNetworks._tr_count_eq","text":"_tr_count_eq(i, x)\n_tr_count_eq(x)\n\nCount the number of elements equal to x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_eq_left","page":"Transformation","title":"CompositionalNetworks._tr_count_eq_left","text":"_tr_count_eq_left(i, x)\n_tr_count_eq_left(x)\n\nCount the number of elements to the left of and equal to x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_eq_right","page":"Transformation","title":"CompositionalNetworks._tr_count_eq_right","text":"_tr_count_eq_right(i, x)\n_tr_count_eq_right(x)\n\nCount the number of elements to the right of and equal to x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_greater","page":"Transformation","title":"CompositionalNetworks._tr_count_greater","text":"_tr_count_greater(i, x)\n_tr_count_greater(x)\n\nCount the number of elements greater than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_lesser","page":"Transformation","title":"CompositionalNetworks._tr_count_lesser","text":"_tr_count_lesser(i, x)\n_tr_count_lesser(x)\n\nCount the number of elements lesser than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_g_left","page":"Transformation","title":"CompositionalNetworks._tr_count_g_left","text":"_tr_count_g_left(i, x)\n_tr_count_g_left(x)\n\nCount the number of elements to the left of and greater than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_l_left","page":"Transformation","title":"CompositionalNetworks._tr_count_l_left","text":"_tr_count_l_left(i, x)\n_tr_count_l_left(x)\n\nCount the number of elements to the left of and lesser than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_g_right","page":"Transformation","title":"CompositionalNetworks._tr_count_g_right","text":"_tr_count_g_right(i, x)\n_tr_count_g_right(x)\n\nCount the number of elements to the right of and greater than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_l_right","page":"Transformation","title":"CompositionalNetworks._tr_count_l_right","text":"_tr_count_l_right(i, x)\n_tr_count_l_right(x)\n\nCount the number of elements to the right of and lesser than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_contiguous_vals_minus","page":"Transformation","title":"CompositionalNetworks._tr_contiguous_vals_minus","text":"_tr_contiguous_vals_minus(i, x)\n_tr_contiguous_vals_minus(x)\n\nReturn the difference x[i] - x[i + 1] if positive, 0.0 otherwise. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_contiguous_vals_minus_rev","page":"Transformation","title":"CompositionalNetworks._tr_contiguous_vals_minus_rev","text":"_tr_contiguous_vals_minus_rev(i, x)\n_tr_contiguous_vals_minus_rev(x)\n\nReturn the difference x[i + 1] - x[i] if positive, 0.0 otherwise. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"Note that all functions are extended to a vectorized version with the lazy function.","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"CompositionalNetworks.lazy","category":"page"},{"location":"transformation/#CompositionalNetworks.lazy","page":"Transformation","title":"CompositionalNetworks.lazy","text":"lazy(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. A function f should have the following signature: f(i::Int, x::V; param = nothing).\n\n\n\n\n\n","category":"function"},{"location":"transformation/#Parametric-transformations","page":"Transformation","title":"Parametric transformations","text":"","category":"section"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"And finally a list of the parametric ones.","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"CompositionalNetworks._tr_count_eq_param\nCompositionalNetworks._tr_count_l_param\nCompositionalNetworks._tr_count_g_param\nCompositionalNetworks._tr_count_bounding_param\nCompositionalNetworks._tr_val_minus_param\nCompositionalNetworks._tr_param_minus_val","category":"page"},{"location":"transformation/#CompositionalNetworks._tr_count_eq_param","page":"Transformation","title":"CompositionalNetworks._tr_count_eq_param","text":"_tr_count_eq_param(i, x; param)\n_tr_count_eq_param(x; param)\n\nCount the number of elements equal to x[i] + param. Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_l_param","page":"Transformation","title":"CompositionalNetworks._tr_count_l_param","text":"_tr_count_l_param(i, x; param)\n_tr_count_l_param(x; param)\n\nCount the number of elements lesser than x[i] + param. Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_g_param","page":"Transformation","title":"CompositionalNetworks._tr_count_g_param","text":"_tr_count_g_param(i, x; param)\n_tr_count_g_param(x; param)\n\nCount the number of elements greater than x[i] + param. Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_count_bounding_param","page":"Transformation","title":"CompositionalNetworks._tr_count_bounding_param","text":"_tr_count_bounding_param(i, x; param)\n_tr_count_bounding_param(x; param)\n\nCount the number of elements bounded (not strictly) by x[i] and x[i] + param. An extended method to vector with sig (x, param) is generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_val_minus_param","page":"Transformation","title":"CompositionalNetworks._tr_val_minus_param","text":"_tr_val_minus_param(i, x; param)\n_tr_val_minus_param(x; param)\n\nReturn the difference x[i] - param if positive, 0.0 otherwise.  Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#CompositionalNetworks._tr_param_minus_val","page":"Transformation","title":"CompositionalNetworks._tr_param_minus_val","text":"_tr_param_minus_val(i, x; param)\n_tr_param_minus_val(x; param)\n\nReturn the difference param - x[i] if positive, 0.0 otherwise.  Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"function"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"Note that all functions are extended to a vectorized version with the lazy_param function.","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"CompositionalNetworks.lazy_param","category":"page"},{"location":"transformation/#CompositionalNetworks.lazy_param","page":"Transformation","title":"CompositionalNetworks.lazy_param","text":"lazy_param(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. A function f should have the following signature: f(i::Int, x::V; param).\n\n\n\n\n\n","category":"function"}]
}
