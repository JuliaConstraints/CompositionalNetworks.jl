var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CompositionalNetworks","category":"page"},{"location":"#Compositional-Networks","page":"Home","title":"Compositional Networks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CompositionalNetworks]","category":"page"},{"location":"#CompositionalNetworks.ICN","page":"Home","title":"CompositionalNetworks.ICN","text":"ICN(; nvars, dom_size, param, transformation, arithmetic, aggregation, comparison)\n\nConstruct an Interpretable Compositional Network, with the following arguments:\n\nnvars: number of variable in the constraint\ndom_size: maximum domain size of any variable in the constraint\nparam: optional parameter (default to nothing)\ntransformation: a transformation layer (optional)\narithmetic: a arithmetic layer (optional)\naggregation: a aggregation layer (optional)\ncomparison: a comparison layer (optional)\n\n\n\n\n\n","category":"type"},{"location":"#CompositionalNetworks._abs_diff_val_param-Union{Tuple{T}, Tuple{T,T}} where T<:Number","page":"Home","title":"CompositionalNetworks._abs_diff_val_param","text":"_abs_diff_val_param(x::T, param::T)\n\nReturn the absolute difference between x and param.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._abs_diff_val_vars-Union{Tuple{T}, Tuple{T,Int64}} where T<:Number","page":"Home","title":"CompositionalNetworks._abs_diff_val_vars","text":"_abs_diff_val_vars(x::T, nvars::Int)\n\nReturn the absolute difference between x and the number of variables.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._as_bitvector","page":"Home","title":"CompositionalNetworks._as_bitvector","text":"_as_bitvector(n::Int, max_n::Int = n)\n\nConvert an Int to a BitVector of minimal size (relatively to max_n).\n\n\n\n\n\n","category":"function"},{"location":"#CompositionalNetworks._as_int-Tuple{AbstractArray{T,1} where T}","page":"Home","title":"CompositionalNetworks._as_int","text":"_as_bitvector(v::AbstractVector)\n\nConvert a BitVector into an Int.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._contiguous_vals_minus-Union{Tuple{V}, Tuple{T}, Tuple{Int64,V}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._contiguous_vals_minus","text":"_contiguous_vals_minus(i::Int, x::V)\n_contiguous_vals_minus_rev(i::Int, x::V)\n\nReturn the difference x[i] - x[i + 1] (resp. x[i + 1] - x[i]) if positive, 0.0 otherwise. Extended method to vector with sig (x::V) are generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._count_bounding_param-Union{Tuple{V}, Tuple{T}, Tuple{Int64,V,T}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._count_bounding_param","text":"_count_bounding_param(i::Int, x::V, param::T)\n\nCount the number of elements bounded (not strictly) by x[i] and x[i] + param. An extended method to vector with sig (x::V, param::T) is generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._count_eq-Union{Tuple{V}, Tuple{T}, Tuple{Int64,V}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._count_eq","text":"_count_eq(i::Int, x::V)\n_count_eq_right(i::Int, x::V)\n_count_eq_left(i::Int, x::V)\n\nCount the number of elements equal to x[i] (optionally to the right/left of x[i]). Extended method to vector x::V are generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._count_eq_param-Union{Tuple{V}, Tuple{T}, Tuple{Int64,V,T}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._count_eq_param","text":"_count_eq_param(i::Int, x::V, param::T)\n_count_l_param(i::Int, x::V, param::T)\n_count_g_param(i::Int, x::V, param::T)\n\nCount the number of elements equal to (resp. lesser/greater than) x[i] + param. Extended method to vector with sig (x::V, param::T) are generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._count_greater-Union{Tuple{V}, Tuple{T}, Tuple{Int64,V}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._count_greater","text":"_count_greater(i::Int, x::V)\n_count_lesser(i::Int, x::V)\n_count_g_left(i::Int, x::V)\n_count_l_left(i::Int, x::V)\n_count_g_right(i::Int, x::V)\n_count_l_right(i::Int, x::V)\n\nCount the number of elements greater/lesser than x[i] (optionally to the left/right of x[i]). Extended method to vector with sig (x::V) are generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._count_positive-Union{Tuple{V}, Tuple{T}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._count_positive","text":"_count_positive(x::V)\n\nCount the number of strictly positive elements of x.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._euclidian_param-Union{Tuple{T2}, Tuple{T}, Tuple{T,T,T2}} where T2<:Number where T<:Number","page":"Home","title":"CompositionalNetworks._euclidian_param","text":"_euclidian_param(x::T, param::T, dom_size::T2)\n_euclidian(x::T, dom_size::T2)\n\nCompute an euclidian norm , possibly weigthed by param, on a scalar.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._exclu-Tuple{Any}","page":"Home","title":"CompositionalNetworks._exclu","text":"_exclu(layer)\n\nReturn true if the layer has mutually exclusive operations.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._functions-Tuple{Any}","page":"Home","title":"CompositionalNetworks._functions","text":"_functions(layer)\n\nAccess the operations of a layer. The container is ordered.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._identity-Union{Tuple{V}, Tuple{T}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._identity","text":"_identity(x::V) where {T <: Number,V <: AbstractVector{T}}\n_identity(x::T) where T <: Number = identity(x)\n\nIdentity function. Already defined in Julia as identity, specialized for vectors and scalars.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._layers-Tuple{Any}","page":"Home","title":"CompositionalNetworks._layers","text":"_layers(icn)\n\nReturn the ordered layers of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._length-Tuple{CompositionalNetworks.Layer}","page":"Home","title":"CompositionalNetworks._length","text":"_length(layer)\n\nReturn the number of operations in a layer.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._length-Tuple{ICN}","page":"Home","title":"CompositionalNetworks._length","text":"_length(icn)\n\nReturn the total number of operations of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._map_tr-Tuple{Any,Any}","page":"Home","title":"CompositionalNetworks._map_tr","text":"_map_tr(f, x)\n_map_tr(f, x, param)\n\nReturn an anonymous function that applies f to all elements of x, with an optional parameter param.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._nbits_exclu-Tuple{Any}","page":"Home","title":"CompositionalNetworks._nbits_exclu","text":"_nbits_exclu(layer)\n\nConvert the length of an exclusive layer into a number of bits.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._sum-Union{Tuple{V}, Tuple{T}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._sum","text":"_sum(x::V)\n\nAggregate through + a vector into a single scalar.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._sum-Union{Tuple{W}, Tuple{V}, Tuple{T}} where W<:AbstractArray{V,1} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._sum","text":"_sum(x::W) where {T <: Number, V <: AbstractVector{T}, W <: AbstractVector{V}}\n_prod(x::W) where {T <: Number, V <: AbstractVector{T}, W <: AbstractVector{V}}\n\nReduce k = length(x) vectors through sum/product to a single vector.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._symbol-Tuple{Any,Any}","page":"Home","title":"CompositionalNetworks._symbol","text":"_symbol(layer, i)\n\nReturn the i-th symbols of the operations in a given layer. \n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._val_minus_param-Union{Tuple{T}, Tuple{T,T}} where T<:Number","page":"Home","title":"CompositionalNetworks._val_minus_param","text":"_val_minus_param(x::T, param::T)\n_param_minus_val(x::T, param::T)\n\nReturn the difference x - param (resp. param - x) if positive, 0.0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._val_minus_param-Union{Tuple{V}, Tuple{T}, Tuple{Int64,V,T}} where V<:AbstractArray{T,1} where T<:Number","page":"Home","title":"CompositionalNetworks._val_minus_param","text":"_val_minus_param(i::Int, x::V, param::T)\n_param_minus_val(i::Int, x::V, param::T)\n\nReturn the difference x[i] - param (resp. param - x[i]) if positive, 0.0 otherwise.  Extended method to vector with sig (x::V, param::T) are generated.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._val_minus_vars-Union{Tuple{T}, Tuple{T,Int64}} where T<:Number","page":"Home","title":"CompositionalNetworks._val_minus_vars","text":"_val_minus_vars(x::T, nvars::Int)\n_vars_minus_val(x::T, nvars::Int)\n\nReturn the difference x - nvars (resp. nvars - x) if positive, 0.0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks._weigths-Tuple{Any}","page":"Home","title":"CompositionalNetworks._weigths","text":"_weigths(icn)\n\nAccess the current set of weigths of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.aggregation_layer-Tuple{}","page":"Home","title":"CompositionalNetworks.aggregation_layer","text":"aggregation_layer()\n\nGenerate the layer of aggregation functions of the ICN.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.arithmetic_layer-Tuple{}","page":"Home","title":"CompositionalNetworks.arithmetic_layer","text":"arithmetic_layer()\n\nGenerate the layer of arithmetic functions of the ICN.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.comparison_layer","page":"Home","title":"CompositionalNetworks.comparison_layer","text":"comparison_layer(nvars, dom_size, param = nothing)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is set, also includes all the parametric transformation with that value.\n\n\n\n\n\n","category":"function"},{"location":"#CompositionalNetworks.compose-Tuple{ICN}","page":"Home","title":"CompositionalNetworks.compose","text":"compose(icn)\n\nReturn a function composed by some of the operations of a given ICN. Can be applied to any vector of variables.\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.lazy-Tuple{Vararg{Function,N} where N}","page":"Home","title":"CompositionalNetworks.lazy","text":"lazy(funcs::Function...)\nlazy_param(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. For lazy (resp. lazy_param) a function f should have the following signature: f(i::Int, x::V) (resp. f(i::Int, x::V, param::T)).\n\n\n\n\n\n","category":"method"},{"location":"#CompositionalNetworks.transformation_layer","page":"Home","title":"CompositionalNetworks.transformation_layer","text":"transformation_layer(param = nothing)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is set, also includes all the parametric transformation with that value.\n\n\n\n\n\n","category":"function"}]
}
