var documenterSearchIndex = {"docs":
[{"location":"domain/#ConstraintDomains.jl-(dependency)","page":"ConstraintDomains.jl","title":"ConstraintDomains.jl (dependency)","text":"","category":"section"},{"location":"domain/","page":"ConstraintDomains.jl","title":"ConstraintDomains.jl","text":"Currently only discrete domains are supported using the following function. ","category":"page"},{"location":"domain/","page":"ConstraintDomains.jl","title":"ConstraintDomains.jl","text":"ConstraintDomains.domain","category":"page"},{"location":"domain/#ConstraintDomains.domain","page":"ConstraintDomains.jl","title":"ConstraintDomains.domain","text":"domain()\n\nConstruct an EmptyDomain.\n\n\n\n\n\ndomain(a::Tuple{T, Bool}, b::Tuple{T, Bool}) where {T <: Real}\ndomain(intervals::Vector{Tuple{Tuple{T, Bool},Tuple{T, Bool}}}) where {T <: Real}\n\nConstruct a domain of continuous interval(s). ```julia d1 = domain((0., true), (1., false)) # d1 = [0, 1) d2 = domain([ # d2 = 0, 1) ∪ (3.5, 42, (1., false),     (3.5, false), (42., true), ])\n\n\n\n\n\ndomain(values)\ndomain(range::R) where {T <: Real, R <: AbstractRange{T}}\n\nConstruct either a SetDomain or a RangeDomain.\n\nd1 = domain(1:5)\nd2 = domain([53.69, 89.2, 0.12])\nd3 = domain([2//3, 89//123])\nd4 = domain(4.3)\n\n\n\n\n\n","category":"function"},{"location":"comparison/#Comparison-Layer","page":"Comparison","title":"Comparison Layer","text":"","category":"section"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"The comparison layer of our basic ICN can be constructed using comparison_layer(param=false). All operations are mutually exclusive.","category":"page"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"CompositionalNetworks.comparison_layer","category":"page"},{"location":"comparison/#CompositionalNetworks.comparison_layer","page":"Comparison","title":"CompositionalNetworks.comparison_layer","text":"comparison_layer(param = false)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is set, also includes all the parametric comparison with that value. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#Non-parametric-comparisons","page":"Comparison","title":"Non-parametric comparisons","text":"","category":"section"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"Follows a list of the current non-parametric operations available in any comparison layer.","category":"page"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"CompositionalNetworks._co_identity\nCompositionalNetworks._co_euclidian\nCompositionalNetworks._co_abs_diff_val_vars\nCompositionalNetworks._co_val_minus_vars\nCompositionalNetworks._co_vars_minus_val","category":"page"},{"location":"comparison/#Parametric-comparisons","page":"Comparison","title":"Parametric comparisons","text":"","category":"section"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"And finally a list of the parametric ones.","category":"page"},{"location":"comparison/","page":"Comparison","title":"Comparison","text":"CompositionalNetworks._co_abs_diff_val_param\nCompositionalNetworks._co_val_minus_param\nCompositionalNetworks._co_param_minus_val\nCompositionalNetworks._co_euclidian_param","category":"page"},{"location":"icn/#ICNs","page":"ICNs","title":"ICNs","text":"","category":"section"},{"location":"icn/","page":"ICNs","title":"ICNs","text":"Currently only construct a generic ICN with all available operations.","category":"page"},{"location":"icn/","page":"ICNs","title":"ICNs","text":"CompositionalNetworks.ICN","category":"page"},{"location":"icn/#CompositionalNetworks.ICN","page":"ICNs","title":"CompositionalNetworks.ICN","text":"ICN(; nvars, dom_size, param, transformation, arithmetic, aggregation, comparison)\n\nConstruct an Interpretable Compositional Network, with the following arguments:\n\nnvars: number of variable in the constraint\ndom_size: maximum domain size of any variable in the constraint\nparam: optional parameter (default to nothing)\ntransformation: a transformation layer (optional)\narithmetic: a arithmetic layer (optional)\naggregation: a aggregation layer (optional)\ncomparison: a comparison layer (optional)\n\n\n\n\n\n","category":"type"},{"location":"public/#Public","page":"Public","title":"Public","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]\nDepth = 5","category":"page"},{"location":"public/","page":"Public","title":"Public","text":"Modules = [CompositionalNetworks]\nPrivate = false","category":"page"},{"location":"public/#CompositionalNetworks.aggregation_layer-Tuple{}","page":"Public","title":"CompositionalNetworks.aggregation_layer","text":"aggregation_layer()\n\nGenerate the layer of aggregations of the ICN. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.arithmetic_layer-Tuple{}","page":"Public","title":"CompositionalNetworks.arithmetic_layer","text":"arithmetic_layer()\n\nGenerate the layer of arithmetic operations of the ICN. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.comparison_layer","page":"Public","title":"CompositionalNetworks.comparison_layer","text":"comparison_layer(param = false)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is set, also includes all the parametric comparison with that value. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"function"},{"location":"public/#CompositionalNetworks.compose","page":"Public","title":"CompositionalNetworks.compose","text":"compose(icn, weights=nothing)\n\nReturn a function composed by some of the operations of a given ICN. Can be applied to any vector of variables. If weights are given, will assign to icn.\n\n\n\n\n\n","category":"function"},{"location":"public/#CompositionalNetworks.compose_to_file!-Tuple{Any, Any, Any}","page":"Public","title":"CompositionalNetworks.compose_to_file!","text":"compose_to_file!(concept, name, path; domains, param = nothing, language = :Julia, search = :complete, global_iter = 10, local_iter = 100, metric = hamming, popSize = 200)\n\nExplore, learn and compose a function and write it to a file.\n\nArguments:\n\nconcept: the concept to learn\nname: the name to give to the constraint\npath: path of the output file\n\nKeywords arguments:\n\ndomains: domains that defines the search space\nparam: an optional paramater of the constraint\nlanguage: the language to export to, default to :julia\nsearch: either :partial or :complete search\nglobal_iter: number of learning iteration\nlocal_iter: number of generation in the genetic algorithm\nmetric: the metric to measure the distance between a configuration and known solutions\npopSize: size of the population in the genetic algorithm\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.explore","page":"Public","title":"CompositionalNetworks.explore","text":"explore(domains, concept, param = nothing; search_limit = 1000, solutions_limit = 100)\n\nSearch (a part of) a search space and returns a pair of vector of configurations: (solutions, non_solutions). If the search space size is over search_limit, then both solutions and non_solutions are limited to solutions_limit.\n\nBeware that if the density of the solutions in the search space is low, solutions_limit needs to be reduced. This process will be automatic in the future (simple reinforcement learning).\n\nArguments:\n\ndomains: a collection of domains\nconcept: the concept of the targeted constraint\nparam: an optional parameter of the constraint\nsol_number: the required number of solutions (half of the number of configurations), default to 100\n\n\n\n\n\n","category":"function"},{"location":"public/#CompositionalNetworks.explore_learn_compose","page":"Public","title":"CompositionalNetworks.explore_learn_compose","text":"explore_learn_compose(concept; domains, param = nothing, search = :complete, global_iter = 10, local_iter = 100, metric = hamming, popSize = 200, action = :composition)\n\nExplore a search space, learn a composition from an ICN, and compose an error function.\n\nArguments:\n\nconcept: the concept of the targeted constraint\ndomains: domains of the variables that define the training space\nparam: an optional parameter of the constraint\nsearch: either flexible,:partial or :complete search. Flexible search will use search_limit and solutions_limit to determine if the search space needs to be partially or completely explored\nglobal_iter: number of learning iteration\nlocal_iter: number of generation in the genetic algorithm\nmetric: the metric to measure the distance between a configuration and known solutions\npopSize: size of the population in the genetic algorithm\naction: either :symbols to have a description of the composition or :composition to have the composed function itself\n\n\n\n\n\n","category":"function"},{"location":"public/#CompositionalNetworks.hamming-Tuple{Any, Any}","page":"Public","title":"CompositionalNetworks.hamming","text":"hamming(x, X)\n\nCompute the hamming distance of x over a collection of solutions X, i.e. the minimal number of variables to switch in xto reach a solution.\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.lazy-Tuple{Vararg{Function, N} where N}","page":"Public","title":"CompositionalNetworks.lazy","text":"lazy(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. A function f should have the following signature: f(i::Int, x::V; param = nothing).\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.lazy_param-Tuple{Vararg{Function, N} where N}","page":"Public","title":"CompositionalNetworks.lazy_param","text":"lazy_param(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. A function f should have the following signature: f(i::Int, x::V; param).\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.learn_compose","page":"Public","title":"CompositionalNetworks.learn_compose","text":"learn_compose(;\n    nvars, dom_size, param=nothing, icn=ICN(nvars, dom_size, param),\n    X, X_sols, global_iter=100, local_iter=100, metric=hamming, popSize=200\n)\n\nCreate an ICN, optimize it, and return its composition.\n\n\n\n\n\n","category":"function"},{"location":"public/#CompositionalNetworks.manhattan-Tuple{Any, Any}","page":"Public","title":"CompositionalNetworks.manhattan","text":"manhattan(x, X)\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.minkowski-Tuple{Any, Any, Any}","page":"Public","title":"CompositionalNetworks.minkowski","text":"minkowski(x, X, p)\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.optimize!-NTuple{9, Any}","page":"Public","title":"CompositionalNetworks.optimize!","text":"optimize!(icn, X, X_sols, global_iter, local_iter; metric=hamming, popSize=100)\n\nOptimize and set the weigths of an ICN with a given set of configuration X and solutions X_sols. The best weigths among global_iter will be set.\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.regularization-Tuple{Any}","page":"Public","title":"CompositionalNetworks.regularization","text":"regularization(icn)\n\nReturn the regularization value of an ICN weights, which is proportional to the normalized number of operations selected in the icn layers.\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.show_layers-Tuple{Any}","page":"Public","title":"CompositionalNetworks.show_layers","text":"show_layers(icn)\n\nReturn a formated string with each layers in the icn.\n\n\n\n\n\n","category":"method"},{"location":"public/#CompositionalNetworks.transformation_layer","page":"Public","title":"CompositionalNetworks.transformation_layer","text":"transformation_layer(param = false)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is true, also includes all the parametric transformations.\n\n\n\n\n\n","category":"function"},{"location":"internal/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internal/","page":"Internals","title":"Internals","text":"Pages = [\"internal.md\"]\nDepth = 5","category":"page"},{"location":"internal/","page":"Internals","title":"Internals","text":"Modules = [CompositionalNetworks]\nPublic = false","category":"page"},{"location":"internal/#CompositionalNetworks.Layer","page":"Internals","title":"CompositionalNetworks.Layer","text":"Layer\n\nA structure to store a LittleDict of operations that can be selected during the learning phase of an ICN. If the layer is exclusive, only one operation can be selected at a time.\n\n\n\n\n\n","category":"type"},{"location":"internal/#Base.length-Tuple{CompositionalNetworks.Layer}","page":"Internals","title":"Base.length","text":"length(layer)\n\nReturn the number of operations in a layer.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Base.length-Tuple{ICN}","page":"Internals","title":"Base.length","text":"Base.length(icn)\n\nReturn the total number of operations of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._compose-Tuple{ICN}","page":"Internals","title":"CompositionalNetworks._compose","text":"_compose(icn)\n\nInternal function called by compose and show_composition.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks._optimize!-NTuple{8, Any}","page":"Internals","title":"CompositionalNetworks._optimize!","text":"_optimize!(icn, X, X_sols; metric = hamming, pop_size = 200)\n\nOptimize and set the weigths of an ICN with a given set of configuration X and solutions X_sols.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.ag_count_positive-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.ag_count_positive","text":"ag_count_positive(x)\n\nCount the number of strictly positive elements of x.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.ag_sum-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.ag_sum","text":"ag_sum(x)\n\nAggregate through + a vector into a single scalar.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.ar_prod-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.ar_prod","text":"ar_prod(x)\n\nReduce k = length(x) vectors through product to a single vector.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.ar_sum-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.ar_sum","text":"ar_sum(x)\n\nReduce k = length(x) vectors through sum to a single vector.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.as_bitvector","page":"Internals","title":"CompositionalNetworks.as_bitvector","text":"as_bitvector(n::Int, max_n::Int = n)\n\nConvert an Int to a BitVector of minimal size (relatively to max_n).\n\n\n\n\n\n","category":"function"},{"location":"internal/#CompositionalNetworks.as_int-Tuple{AbstractVector{T} where T}","page":"Internals","title":"CompositionalNetworks.as_int","text":"as_int(v::AbstractVector)\n\nConvert a BitVector into an Int.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.co_abs_diff_val_param-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.co_abs_diff_val_param","text":"co_abs_diff_val_param(x; param)\n\nReturn the absolute difference between x and param.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.co_abs_diff_val_vars-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.co_abs_diff_val_vars","text":"co_abs_diff_val_vars(x; nvars)\n\nReturn the absolute difference between x and the number of variables nvars.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.co_euclidian-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.co_euclidian","text":"co_euclidian(x; dom_size)\n\nCompute an euclidian norm with domain size dom_size of a scalar.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.co_euclidian_param-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.co_euclidian_param","text":"co_euclidian_param(x; param, dom_size)\n\nCompute an euclidian norm with domain size dom_size, weigthed by param, of a scalar.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.co_identity-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.co_identity","text":"co_identity(x)\n\nIdentity function. Already defined in Julia as identity, specialized for scalars in the comparison layer.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.co_param_minus_val-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.co_param_minus_val","text":"co_param_minus_val(x; param)\n\nReturn the difference param - x if positive, 0.0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.co_val_minus_param-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.co_val_minus_param","text":"co_val_minus_param(x; param)\n\nReturn the difference x - param if positive, 0.0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.co_val_minus_vars-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.co_val_minus_vars","text":"co_val_minus_vars(x; nvars)\n\nReturn the difference x - nvars if positive, 0.0 otherwise, where nvars denotes the numbers of variables.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.co_vars_minus_val-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.co_vars_minus_val","text":"co_vars_minus_val(x; nvars)\n\nReturn the difference nvars - x if positive, 0.0 otherwise, where nvars denotes the numbers of variables.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.exclu-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.exclu","text":"exclu(layer)\n\nReturn true if the layer has mutually exclusive operations.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.functions-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.functions","text":"functions(layer)\n\nAccess the operations of a layer. The container is ordered.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.generate_inclusive_operations-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.generate_inclusive_operations","text":"generate_inclusive_operations(predicate, bits)\ngenerate_exclusive_operation(max_op_number)\n\nGenerates the operations (weigths) of a layer with inclusive/exclusive operations.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.generate_population-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.generate_population","text":"generate_population(icn, pop_size\n\nGenerate a pôpulation of weigths (individuals) for the genetic algorithm weigthing icn.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.generate_weights-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.generate_weights","text":"generate_weights(layers)\ngenerate_weights(icn)\n\nGenerate the weigths of a collection of layers or of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.is_viable-Tuple{CompositionalNetworks.Layer, Any}","page":"Internals","title":"CompositionalNetworks.is_viable","text":"is_viable(layer, w)\nis_viable(icn)\nis_viable(icn, w)\n\nAssert if a pair of layer/icn and weigths compose a viable pattern. If no weigths are given with an icn, it will check the current internal value.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.layers-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.layers","text":"layers(icn)\n\nReturn the ordered layers of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.loss-NTuple{7, Any}","page":"Internals","title":"CompositionalNetworks.loss","text":"loss(X, X_sols, icn, weigths, metric)\n\nCompute the loss of icn.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.map_tr-Tuple{Any, Any, Any}","page":"Internals","title":"CompositionalNetworks.map_tr","text":"map_tr(f, x, param)\n\nReturn an anonymous function that applies f to all elements of x, with a parameter param (which is set to nothing for function with no parameter).\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.nbits-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.nbits","text":"nbits(icn)\n\nReturn the expected number of bits of a viable weigth of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.nbits_exclu-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.nbits_exclu","text":"nbits_exclu(layer)\n\nConvert the length of an exclusive layer into a number of bits.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.reduce_symbols","page":"Internals","title":"CompositionalNetworks.reduce_symbols","text":"reduce_symbols(symbols, sep)\n\nProduce a formatted string that separates the symbols by sep. Used internally for show_composition.\n\n\n\n\n\n","category":"function"},{"location":"internal/#CompositionalNetworks.selected_size-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.selected_size","text":"selected_size(layer, layer_weights)\n\nReturn the number of operations selected by layer_weights in layer.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.show_layer-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.show_layer","text":"show_layer(layer)\n\nReturn a string that contains the elements in a layer.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.symbol-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.symbol","text":"symbol(layer, i)\n\nReturn the i-th symbols of the operations in a given layer.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_contiguous_vals_minus-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_contiguous_vals_minus","text":"tr_contiguous_vals_minus(i, x)\ntr_contiguous_vals_minus(x)\n\nReturn the difference x[i] - x[i + 1] if positive, 0.0 otherwise. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_contiguous_vals_minus_rev-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_contiguous_vals_minus_rev","text":"tr_contiguous_vals_minus_rev(i, x)\ntr_contiguous_vals_minus_rev(x)\n\nReturn the difference x[i + 1] - x[i] if positive, 0.0 otherwise. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_count_bounding_param-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_count_bounding_param","text":"tr_count_bounding_param(i, x; param)\ntr_count_bounding_param(x; param)\n\nCount the number of elements bounded (not strictly) by x[i] and x[i] + param. An extended method to vector with sig (x, param) is generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_count_eq-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_count_eq","text":"tr_count_eq(i, x)\ntr_count_eq(x)\n\nCount the number of elements equal to x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_count_eq_left-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_count_eq_left","text":"tr_count_eq_left(i, x)\ntr_count_eq_left(x)\n\nCount the number of elements to the left of and equal to x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_count_eq_param-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_count_eq_param","text":"tr_count_eq_param(i, x; param)\ntr_count_eq_param(x; param)\n\nCount the number of elements equal to x[i] + param. Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_count_eq_right-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_count_eq_right","text":"tr_count_eq_right(i, x)\ntr_count_eq_right(x)\n\nCount the number of elements to the right of and equal to x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_count_g_left-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_count_g_left","text":"tr_count_g_left(i, x)\ntr_count_g_left(x)\n\nCount the number of elements to the left of and greater than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_count_g_param-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_count_g_param","text":"tr_count_g_param(i, x; param)\ntr_count_g_param(x; param)\n\nCount the number of elements greater than x[i] + param. Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_count_g_right-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_count_g_right","text":"tr_count_g_right(i, x)\ntr_count_g_right(x)\n\nCount the number of elements to the right of and greater than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_count_greater-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_count_greater","text":"tr_count_greater(i, x)\ntr_count_greater(x)\n\nCount the number of elements greater than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_count_l_left-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_count_l_left","text":"tr_count_l_left(i, x)\ntr_count_l_left(x)\n\nCount the number of elements to the left of and lesser than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_count_l_param-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_count_l_param","text":"tr_count_l_param(i, x; param)\ntr_count_l_param(x; param)\n\nCount the number of elements lesser than x[i] + param. Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_count_l_right-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_count_l_right","text":"tr_count_l_right(i, x)\ntr_count_l_right(x)\n\nCount the number of elements to the right of and lesser than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_count_lesser-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_count_lesser","text":"tr_count_lesser(i, x)\ntr_count_lesser(x)\n\nCount the number of elements lesser than x[i]. Extended method to vector with sig (x) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_identity-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.tr_identity","text":"tr_identity(x)\ntr_identity(i, x)\n\nIdentity function. Already defined in Julia as identity, specialized for vectors.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_param_minus_val-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_param_minus_val","text":"tr_param_minus_val(i, x; param)\ntr_param_minus_val(x; param)\n\nReturn the difference param - x[i] if positive, 0.0 otherwise.  Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.tr_val_minus_param-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.tr_val_minus_param","text":"tr_val_minus_param(i, x; param)\ntr_val_minus_param(x; param)\n\nReturn the difference x[i] - param if positive, 0.0 otherwise.  Extended method to vector with sig (x, param) are generated.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.weights!-Tuple{Any, Any}","page":"Internals","title":"CompositionalNetworks.weights!","text":"weights!(icn, weights)\n\nSet the weights of an ICN with a BitVector.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.weigths-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.weigths","text":"weigths(icn)\n\nAccess the current set of weigths of an ICN.\n\n\n\n\n\n","category":"method"},{"location":"internal/#CompositionalNetworks.weigths_bias-Tuple{Any}","page":"Internals","title":"CompositionalNetworks.weigths_bias","text":"weigths_bias(x)\n\nA metric that bias x towards operations with a lower bit. Do not affect the main metric.\n\n\n\n\n\n","category":"method"},{"location":"aggregation/#Aggregation-Layer","page":"Aggregation","title":"Aggregation Layer","text":"","category":"section"},{"location":"aggregation/","page":"Aggregation","title":"Aggregation","text":"The aggregation layer of our basic ICN can be constructed using aggregation_layer().","category":"page"},{"location":"aggregation/","page":"Aggregation","title":"Aggregation","text":"CompositionalNetworks.aggregation_layer","category":"page"},{"location":"aggregation/#CompositionalNetworks.aggregation_layer","page":"Aggregation","title":"CompositionalNetworks.aggregation_layer","text":"aggregation_layer()\n\nGenerate the layer of aggregations of the ICN. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"function"},{"location":"aggregation/#List-of-Aggregations","page":"Aggregation","title":"List of Aggregations","text":"","category":"section"},{"location":"aggregation/","page":"Aggregation","title":"Aggregation","text":"Follows a list of the current operations available in any aggregation layer. Those operations are mutually exclusive.","category":"page"},{"location":"aggregation/","page":"Aggregation","title":"Aggregation","text":"CompositionalNetworks._ag_sum\nCompositionalNetworks._ag_count_positive","category":"page"},{"location":"arithmetic/#Arithmetic-Layer","page":"Arithmetic","title":"Arithmetic Layer","text":"","category":"section"},{"location":"arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"The arithmetic layer of our basic ICN can be constructed using arithmetic_layer().","category":"page"},{"location":"arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"CompositionalNetworks.arithmetic_layer","category":"page"},{"location":"arithmetic/#CompositionalNetworks.arithmetic_layer","page":"Arithmetic","title":"CompositionalNetworks.arithmetic_layer","text":"arithmetic_layer()\n\nGenerate the layer of arithmetic operations of the ICN. The operations are mutually exclusive, that is only one will be selected.\n\n\n\n\n\n","category":"function"},{"location":"arithmetic/#List-of-Arithmetic-operations","page":"Arithmetic","title":"List of Arithmetic operations","text":"","category":"section"},{"location":"arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"Follows a list of the current operations available in any arithmetic layer. Those operations are mutually exclusive.","category":"page"},{"location":"arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"CompositionalNetworks._ar_sum\nCompositionalNetworks._ar_prod","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CompositionalNetworks","category":"page"},{"location":"#CompositionalNetworks.jl","page":"Home","title":"CompositionalNetworks.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CompositionalNetworks.jl, a Julia package for Interpretable Compositional Networks (ICN), a variant of neural networks, allowing the user to get interpretable results, unlike regular artificial neural networks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The current state of our ICN focuses on the composition of error functions for LocalSearchSolvers.jl, but produces results independently of it and export it to either/both Julia functions or/and human readable output.","category":"page"},{"location":"#How-does-it-work?","page":"Home","title":"How does it work?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package comes with a basic ICN for learning global constraints. The ICN is composed of 4 layers: transformation, arithmetic, aggregation, and comparison. Each contains several operations that can be composed in various ways. Given a concept (a predicate over the variables' domains), a metric (hamming by default), and the variables' domains, we learn the binary weights of the ICN. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"] add CompositionalNetworks","category":"page"},{"location":"","page":"Home","title":"Home","text":"As the package is in a beta version, some changes in the syntax and features are likely to occur. However, those changes should be minimal between minor versions. Please update with caution.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# 4 variables in 1:4\ndoms = [domain([1,2,3,4]) for i in 1:4]\n\n# allunique concept (that is used to define the :all_different constraint)\nerr = explore_learn_compose(allunique, domains=doms)\n# > interpretation: identity ∘ count_positive ∘ sum ∘ count_eq_left\n\n# test our new error function\n@assert err([1,2,3,3], dom_size = 4) > 0.0\n\n# export an all_different function to file \"current/path/test_dummy.jl\" \ncompose_to_file!(icn, \"all_different\", \"test_dummy.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output file should produces a function that can be used as follows (assuming the maximum domain size is 7)","category":"page"},{"location":"","page":"Home","title":"Home","text":"import CompositionalNetworks\n\nall_different([1,2,3,4,5,6,7]; dom_size = 7)\n# > 0.0 (which means true, no errors)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please see JuliaConstraints/Constraints.jl/learn.jl for an extensive example of ICN learning and compositions.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions to this package are more than welcome and can be arbitrarily, and not exhaustively, split as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Adding (useful) operations in one of the 4 existing layers\nCreating other ICNs from scratch or with only some of the original operations\nCreating an ICN with a layer structure\nCreating other compositional networks which target other problems\nJust making stuff better, faster, user-friendlier, etc.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Do not hesitate to contact me (@azzaare) or other members of JuliaConstraints on GitHub (file an issue), the julialang discourse forum, the julialang slack channel, the julialang zulip server, or the Human of Julia (HoJ) discord server.","category":"page"},{"location":"transformation/#Transformation-Layer","page":"Transformation","title":"Transformation Layer","text":"","category":"section"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"The transformation layer of our basic ICN can be constructed using transformation_layer(param=false).","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"CompositionalNetworks.transformation_layer","category":"page"},{"location":"transformation/#CompositionalNetworks.transformation_layer","page":"Transformation","title":"CompositionalNetworks.transformation_layer","text":"transformation_layer(param = false)\n\nGenerate the layer of transformations functions of the ICN. Iff param value is true, also includes all the parametric transformations.\n\n\n\n\n\n","category":"function"},{"location":"transformation/#Non-parametric-transformations","page":"Transformation","title":"Non-parametric transformations","text":"","category":"section"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"Follows a list of the current non-parametric operations available in any transformation layer.","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"CompositionalNetworks._tr_identity\nCompositionalNetworks._tr_count_eq\nCompositionalNetworks._tr_count_eq_left\nCompositionalNetworks._tr_count_eq_right\nCompositionalNetworks._tr_count_greater\nCompositionalNetworks._tr_count_lesser\nCompositionalNetworks._tr_count_g_left\nCompositionalNetworks._tr_count_l_left\nCompositionalNetworks._tr_count_g_right\nCompositionalNetworks._tr_count_l_right\nCompositionalNetworks._tr_contiguous_vals_minus\nCompositionalNetworks._tr_contiguous_vals_minus_rev","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"Note that all functions are extended to a vectorized version with the lazy function.","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"CompositionalNetworks.lazy","category":"page"},{"location":"transformation/#CompositionalNetworks.lazy","page":"Transformation","title":"CompositionalNetworks.lazy","text":"lazy(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. A function f should have the following signature: f(i::Int, x::V; param = nothing).\n\n\n\n\n\n","category":"function"},{"location":"transformation/#Parametric-transformations","page":"Transformation","title":"Parametric transformations","text":"","category":"section"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"And finally a list of the parametric ones.","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"CompositionalNetworks._tr_count_eq_param\nCompositionalNetworks._tr_count_l_param\nCompositionalNetworks._tr_count_g_param\nCompositionalNetworks._tr_count_bounding_param\nCompositionalNetworks._tr_val_minus_param\nCompositionalNetworks._tr_param_minus_val","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"Note that all functions are extended to a vectorized version with the lazy_param function.","category":"page"},{"location":"transformation/","page":"Transformation","title":"Transformation","text":"CompositionalNetworks.lazy_param","category":"page"},{"location":"transformation/#CompositionalNetworks.lazy_param","page":"Transformation","title":"CompositionalNetworks.lazy_param","text":"lazy_param(funcs::Function...)\n\nGenerate methods extended to a vector instead of one of its components. A function f should have the following signature: f(i::Int, x::V; param).\n\n\n\n\n\n","category":"function"}]
}
